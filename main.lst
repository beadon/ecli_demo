CCS PCH C Compiler, Version 5.116, 749               20-Nov-23 09:01

               Filename:   C:\Users\beadon\Documents\GitHub\ecli_demo\main.lst

               ROM used:   11916 bytes (9%)
                           Largest free fragment is 65536
               RAM used:   54 (0%) at main() level
                           288 (2%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 126

*
00000:  GOTO   2D8A
.................... #include "main.h"
.................... #include <18F57Q84.h>
.................... //////////// Standard Header file for the PIC18F57Q84 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F57Q84
00004:  MOVFF  4EC,4FA
00008:  MOVFF  4EC,4FB
0000C:  MOVF   4ED,F
0000E:  MOVF   4ED,F
00010:  MOVFF  4EF,4E8
00014:  MOVWF  4F9
00016:  RETURN 0
*
0004A:  MOVLB  5
0004C:  MOVF   xCC,W
0004E:  MULWF  xCE
00050:  MOVFF  4F3,501
00054:  MOVFF  4F4,500
00058:  MULWF  xCF
0005A:  MOVF   4F3,W
0005C:  ADDWF  500,F
0005E:  MOVF   xCD,W
00060:  MULWF  xCE
00062:  MOVF   4F3,W
00064:  ADDWFC 500,W
00066:  MOVWF  502
00068:  MOVLB  0
0006A:  RETURN 0
*
001AC:  TSTFSZ 501
001AE:  BRA    01B6
001B0:  TSTFSZ 502
001B2:  BRA    01B8
001B4:  BRA    01C4
001B6:  INCF   502,F
001B8:  MOVFF  500,4EE
001BC:  DECFSZ 501,F
001BE:  BRA    01B8
001C0:  DECFSZ 502,F
001C2:  BRA    01B8
001C4:  GOTO   0418 (RETURN)
*
008D2:  CLRF   501
008D4:  CLRF   502
008D6:  CLRF   500
008D8:  CLRF   503
008DA:  MOVF   547,W
008DC:  BNZ   08E2
008DE:  MOVF   546,W
008E0:  BZ    0912
008E2:  MOVLW  10
008E4:  MOVWF  548
008E6:  BCF    4D8.0
008E8:  RLCF   544,F
008EA:  RLCF   545,F
008EC:  RLCF   500,F
008EE:  RLCF   503,F
008F0:  MOVF   547,W
008F2:  SUBWF  503,W
008F4:  BNZ   08FA
008F6:  MOVF   546,W
008F8:  SUBWF  500,W
008FA:  BNC   090A
008FC:  MOVF   546,W
008FE:  SUBWF  500,F
00900:  BTFSS  4D8.0
00902:  DECF   503,F
00904:  MOVF   547,W
00906:  SUBWF  503,F
00908:  BSF    4D8.0
0090A:  RLCF   501,F
0090C:  RLCF   502,F
0090E:  DECFSZ 548,F
00910:  BRA    08E6
00912:  GOTO   09DC (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... 
.................... #device ICD=TRUE
.................... #use delay(internal=64MHz)
.................... 
.................... // Supposed to be provided by stdint.h, hardware specific
.................... // required for eCLI.
.................... 
.................... #ifndef UINTPTR_MAX
.................... #define UINTPTR_MAX 0xFFFF
.................... #endif
.................... 
.................... #include "embedded_cli.h"
.................... /**
....................  * This header was automatically built using
....................  * embedded_cli.h and embedded_cli.c
....................  * @date 2023-07-13
....................  *
....................  * MIT License
....................  *
....................  * Copyright (c) 2021 Sviatoslav Kokurin (funbiscuit)
....................  *
....................  * Permission is hereby granted, free of charge, to any person obtaining a copy
....................  * of this software and associated documentation files (the "Software"), to deal
....................  * in the Software without restriction, including without limitation the rights
....................  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
....................  * copies of the Software, and to permit persons to whom the Software is
....................  * furnished to do so, subject to the following conditions:
....................  *
....................  * The above copyright notice and this permission notice shall be included in all
....................  * copies or substantial portions of the Software.
....................  *
....................  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
....................  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
....................  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
....................  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
....................  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
....................  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
....................  * SOFTWARE.
....................  */
.................... #ifndef EMBEDDED_CLI_H
.................... #define EMBEDDED_CLI_H
.................... 
.................... 
.................... #ifdef __cplusplus
.................... 
.................... extern "C" {
.................... #else
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... // cstdint is available only since C++11, so use C header
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // used for proper alignment of cli buffer
.................... #if UINTPTR_MAX == 0xFFFF
.................... #define CLI_UINT uint16_t
.................... #elif UINTPTR_MAX == 0xFFFFFFFF
.................... #define CLI_UINT uint32_t
.................... //#elif UINTPTR_MAX == 0xFFFFFFFFFFFFFFFFu
.................... //#define CLI_UINT uint64_t
.................... #else
.................... #error unsupported pointer size
.................... #endif
.................... 
.................... #define CLI_UINT_SIZE (sizeof(CLI_UINT))
.................... // convert size in bytes to size in terms of CLI_UINTs (rounded up
.................... // if bytes is not divisible by size of single CLI_UINT)
.................... #define BYTES_TO_CLI_UINTS(bytes) \
....................   (((bytes) + CLI_UINT_SIZE - 1)/CLI_UINT_SIZE)
.................... 
.................... 
.................... 
.................... struct CliCommand {
....................     /**
....................      * Name of the command.
....................      * In command "set led 1 1" "set" is name
....................      */
....................     char *name;
.................... 
....................     /**
....................      * String of arguments of the command.
....................      * In command "set led 1 1" "led 1 1" is string of arguments
....................      * Is ended with double 0x00 char
....................      * Use tokenize functions to easily get individual tokens
....................      */
....................     char *args;
.................... };
.................... 
.................... typedef struct CliCommand CliCommand;
.................... 
.................... //typedef void (*WriteCharFuncPtr)(struct EmbeddedCli *cli, char c)
.................... 
.................... struct EmbeddedCli {
....................     /**
....................      * Should write char to connection
....................      * @param cli - pointer to cli that executed this function
....................      * @param c   - actual character to write
....................      */
....................     void (*writeChar)(struct EmbeddedCli *cli, char c);
....................     //void (*writeChar)(void *cli, char c);
.................... 
....................     /**
....................      * Called when command is received and command not found in list of
....................      * command bindings (or binding function is null).
....................      * @param cli     - pointer to cli that executed this function
....................      * @param command - pointer to received command
....................      */
....................     void (*onCommand)(struct EmbeddedCli *cli, CliCommand *command);
.................... 
....................     /**
....................      * Can be used for any application context
....................      */
....................     void *appContext;
.................... 
....................     /**
....................      * Pointer to actual implementation, do not use.
....................      */
....................     void *_impl;
.................... };
.................... 
.................... typedef struct EmbeddedCli EmbeddedCli;
.................... 
.................... /**
....................  * Struct to describe binding of command to function and
....................  */
.................... struct CliCommandBinding {
....................     /**
....................      * Name of command to bind. Should not be NULL.
....................      */
....................     char *name;
.................... 
....................     /**
....................      * Help string that will be displayed when "help <cmd>" is executed.
....................      * Can have multiple lines separated with "\r\n"
....................      * Can be NULL if no help is provided.
....................      */
....................     char *help;
.................... 
....................     /**
....................      * Flag to perform tokenization before calling binding function.
....................      */
....................     bool tokenizeArgs;
.................... 
....................     /**
....................      * Pointer to any specific app context that is required for this binding.
....................      * It will be provided in binding callback.
....................      */
....................     void *context;
.................... 
....................     /**
....................      * Binding function for when command is received.
....................      * If null, default callback (onCommand) will be called.
....................      * @param cli - pointer to cli that is calling this binding
....................      * @param args - string of args (if tokenizeArgs is false) or tokens otherwise
....................      * @param context
....................      */
....................     void (*binding)(struct EmbeddedCli *cli, char *args, void *context);
.................... };
.................... 
.................... typedef struct CliCommandBinding CliCommandBinding;
.................... 
.................... /**
....................  * Configuration to create CLI
....................  */
.................... struct EmbeddedCliConfig {
....................     /**
....................      * Invitation string. Is printed at the beginning of each line with user
....................      * input
....................      */
....................     char *invitation;
....................     
....................     /**
....................      * Size of buffer that is used to store characters until they're processed
....................      */
....................     uint16_t rxBufferSize;
.................... 
....................     /**
....................      * Size of buffer that is used to store current input that is not yet
....................      * sended as command (return not pressed yet)
....................      */
....................     uint16_t cmdBufferSize;
.................... 
....................     /**
....................      * Size of buffer that is used to store previously entered commands
....................      * Only unique commands are stored in buffer. If buffer is smaller than
....................      * entered command (including arguments), command is discarded from history
....................      */
....................     uint16_t historyBufferSize;
.................... 
....................     /**
....................      * Maximum amount of bindings that can be added via addBinding function.
....................      * Cli increases takes extra bindings for internal commands:
....................      * - help
....................      */
....................     uint16_t maxBindingCount;
.................... 
....................     /**
....................      * Buffer to use for cli and all internal structures. If NULL, memory will
....................      * be allocated dynamically. Otherwise this buffer is used and no
....................      * allocations are made
....................      */
....................     CLI_UINT *cliBuffer;
.................... 
....................     /**
....................      * Size of buffer for cli and internal structures (in bytes).
....................      */
....................     uint16_t cliBufferSize;
.................... 
....................     /**
....................      * Whether autocompletion should be enabled.
....................      * If false, autocompletion is disabled but you still can use 'tab' to
....................      * complete current command manually.
....................      */
....................     bool enableAutoComplete;
.................... };
.................... 
.................... typedef struct EmbeddedCliConfig EmbeddedCliConfig;
.................... 
.................... /**
....................  * Returns pointer to default configuration for cli creation. It is safe to
....................  * modify it and then send to embeddedCliNew().
....................  * Returned structure is always the same so do not free and try to use it
....................  * immediately.
....................  * Default values:
....................  * <ul>
....................  * <li>rxBufferSize = 64</li>
....................  * <li>cmdBufferSize = 64</li>
....................  * <li>historyBufferSize = 128</li>
....................  * <li>cliBuffer = NULL (use dynamic allocation)</li>
....................  * <li>cliBufferSize = 0</li>
....................  * <li>maxBindingCount = 8</li>
....................  * <li>enableAutoComplete = true</li>
....................  * </ul>
....................  * @return configuration for cli creation
....................  */
.................... EmbeddedCliConfig *embeddedCliDefaultConfig(void);
.................... 
.................... /**
....................  * Returns how many space in config buffer is required for cli creation
....................  * If you provide buffer with less space, embeddedCliNew will return NULL
....................  * This amount will always be divisible by CLI_UINT_SIZE so allocated buffer
....................  * and internal structures can be properly aligned
....................  * @param config
....................  * @return
....................  */
.................... uint16_t embeddedCliRequiredSize(EmbeddedCliConfig *config);
.................... 
.................... /**
....................  * Create new CLI.
....................  * Memory is allocated dynamically if cliBuffer in config is NULL.
....................  * After CLI is created, override function pointers to start using it
....................  * @param config - config for cli creation
....................  * @return pointer to created CLI
....................  */
.................... EmbeddedCli *embeddedCliNew(EmbeddedCliConfig *config);
.................... 
.................... /**
....................  * Same as calling embeddedCliNew with default config.
....................  * @return
....................  */
.................... EmbeddedCli *embeddedCliNewDefault(void);
.................... 
.................... /**
....................  * Receive character and put it to internal buffer
....................  * Actual processing is done inside embeddedCliProcess
....................  * You can call this function from something like interrupt service routine,
....................  * just make sure that you call it only from single place. Otherwise input
....................  * might get corrupted
....................  * @param cli
....................  * @param c   - received char
....................  */
.................... void embeddedCliReceiveChar(EmbeddedCli *cli, char c);
.................... 
.................... /**
....................  * Process rx/tx buffers. Command callbacks are called from here
....................  * @param cli
....................  */
.................... void embeddedCliProcess(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Add specified binding to list of bindings. If list is already full, binding
....................  * is not added and false is returned
....................  * @param cli
....................  * @param binding
....................  * @return true if binding was added, false otherwise
....................  */
.................... bool embeddedCliAddBinding(EmbeddedCli *cli, CliCommandBinding binding);
.................... 
.................... /**
....................  * Print specified string and account for currently entered but not submitted
....................  * command.
....................  * Current command is deleted, provided string is printed (with new line) after
....................  * that current command is printed again, so user can continue typing it.
....................  * @param cli
....................  * @param string
....................  */
.................... void embeddedCliPrint(EmbeddedCli *cli, char *string);
.................... 
.................... /**
....................  * Free allocated for cli memory
....................  * @param cli
....................  */
.................... void embeddedCliFree(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Perform tokenization of arguments string. Original string is modified and
....................  * should not be used directly (only inside other token functions).
....................  * Individual tokens are separated by single 0x00 char, double 0x00 is put at
....................  * the end of token list. After calling this function, you can use other
....................  * token functions to get individual tokens and token count.
....................  *
....................  * Important: Call this function only once. Otherwise information will be lost if
....................  * more than one token existed
....................  * @param args - string to tokenize (must have extra writable char after 0x00)
....................  * @return
....................  */
.................... void embeddedCliTokenizeArgs(char *args);
.................... 
.................... /**
....................  * Return specific token from tokenized string
....................  * @param tokenizedStr
....................  * @param pos (counted from 1)
....................  * @return token
....................  */
.................... char *embeddedCliGetToken(char *tokenizedStr, uint16_t pos);
.................... 
.................... /**
....................  * Same as embeddedCliGetToken but works on non-buffer
....................  * @param tokenizedStr
....................  * @param pos (counted from 1)
....................  * @return token
....................  */
.................... char *embeddedCliGetTokenVariable(char *tokenizedStr, uint16_t pos);
.................... 
.................... /**
....................  * Find token in provided tokens string and return its position (counted from 1)
....................  * If no such token is found - 0 is returned.
....................  * @param tokenizedStr
....................  * @param token - token to find
....................  * @return position (increased by 1) or zero if no such token found
....................  */
.................... uint16_t embeddedCliFindToken(char *tokenizedStr, char *token);
.................... 
.................... /**
....................  * Return number of tokens in tokenized string
....................  * @param tokenizedStr
....................  * @return number of tokens
....................  */
.................... uint16_t embeddedCliGetTokenCount(char *tokenizedStr);
.................... 
.................... #ifdef __cplusplus
.................... }
.................... #endif
.................... 
.................... 
.................... #endif //EMBEDDED_CLI_H
.................... 
.................... 
.................... #ifdef EMBEDDED_CLI_IMPL
.................... #ifndef EMBEDDED_CLI_IMPL_GUARD
.................... #define EMBEDDED_CLI_IMPL_GUARD
.................... #ifdef __cplusplus
.................... extern "C" {
.................... #endif
.................... #include <stdlib.h>
.................... #include <string.h>
.................... 
.................... 
.................... #define CLI_TOKEN_NPOS 0xffff
.................... 
.................... #ifndef UNUSED
.................... #define UNUSED(x) (void)x
.................... #endif
.................... 
.................... #define PREPARE_IMPL(t) \
....................   EmbeddedCliImpl* impl = (EmbeddedCliImpl*)t->_impl
.................... 
.................... #define IS_FLAG_SET(flags, flag) (((flags) & (flag)) != 0)
.................... 
.................... #define SET_FLAG(flags, flag) ((flags) |= (flag))
.................... 
.................... #define UNSET_U8FLAG(flags, flag) ((flags) &= (uint8_t) ~(flag))
.................... 
.................... /**
....................  * Marks binding as candidate for autocompletion
....................  * This flag is updated each time getAutocompletedCommand is called
....................  */
.................... #define BINDING_FLAG_AUTOCOMPLETE 1u
.................... 
.................... /**
....................  * Indicates that rx buffer overflow happened. In such case last command
....................  * that wasn't finished (no \r or \n were received) will be discarded
....................  */
.................... #define CLI_FLAG_OVERFLOW 0x01u
.................... 
.................... /**
....................  * Indicates that initialization is completed. Initialization is completed in
....................  * first call to process and needed, for example, to print invitation message.
....................  */
.................... #define CLI_FLAG_INIT_COMPLETE 0x02u
.................... 
.................... /**
....................  * Indicates that CLI structure and internal structures were allocated with
....................  * malloc and should bre freed
....................  */
.................... #define CLI_FLAG_ALLOCATED 0x04u
.................... 
.................... /**
....................  * Indicates that CLI structure and internal structures were allocated with
....................  * malloc and should bre freed
....................  */
.................... #define CLI_FLAG_ESCAPE_MODE 0x08u
.................... 
.................... /**
....................  * Indicates that CLI in mode when it will print directly to output without
....................  * clear of current command and printing it back
....................  */
.................... #define CLI_FLAG_DIRECT_PRINT 0x10u
.................... 
.................... /**
....................  * Indicates that live autocompletion is enabled
....................  */
.................... #define CLI_FLAG_AUTOCOMPLETE_ENABLED 0x20u
.................... 
.................... 
.................... struct FifoBuf {
....................     char *buf;
....................     /**
....................      * Position of first element in buffer. From this position elements are taken
....................      */
....................     uint16_t front;
....................     /**
....................      * Position after last element. At this position new elements are inserted
....................      */
....................     uint16_t back;
....................     /**
....................      * Size of buffer
....................      */
....................     uint16_t size;
.................... };
.................... 
.................... typedef struct FifoBuf FifoBuf;
.................... 
.................... struct CliHistory {
....................     /**
....................      * Items in buffer are separated by null-chars
....................      */
....................     char *buf;
.................... 
....................     /**
....................      * Total size of buffer
....................      */
....................     uint16_t bufferSize;
.................... 
....................     /**
....................      * Index of currently selected element. This allows to navigate history
....................      * After command is sent, current element is reset to 0 (no element)
....................      */
....................     uint16_t current;
.................... 
....................     /**
....................      * Number of items in buffer
....................      * Items are counted from top to bottom (and are 1 based).
....................      * So the most recent item is 1 and the oldest is itemCount.
....................      */
....................     uint16_t itemsCount;
.................... };
.................... 
.................... typedef struct CliHistory CliHistory;
.................... 
.................... struct EmbeddedCliImpl {
....................     /**
....................      * Invitation string. Is printed at the beginning of each line with user
....................      * input
....................      */
....................     char *invitation;
.................... 
....................     CliHistory history;
.................... 
....................     /**
....................      * Buffer for storing received chars.
....................      * Chars are stored in FIFO mode.
....................      */
....................     FifoBuf rxBuffer;
.................... 
....................     /**
....................      * Buffer for current command
....................      */
....................     char *cmdBuffer;
.................... 
....................     /**
....................      * Size of current command
....................      */
....................     uint16_t cmdSize;
.................... 
....................     /**
....................      * Total size of command buffer
....................      */
....................     uint16_t cmdMaxSize;
.................... 
....................     CliCommandBinding *bindings;
.................... 
....................     /**
....................      * Flags for each binding. Sizes are the same as for bindings array
....................      */
....................     uint8_t *bindingsFlags;
.................... 
....................     uint16_t bindingsCount;
.................... 
....................     uint16_t maxBindingsCount;
.................... 
....................     /**
....................      * Total length of input line. This doesn't include invitation but
....................      * includes current command and its live autocompletion
....................      */
....................     uint16_t inputLineLength;
.................... 
....................     /**
....................      * Stores last character that was processed.
....................      */
....................     char lastChar;
.................... 
....................     /**
....................      * Flags are defined as CLI_FLAG_*
....................      */
....................     uint8_t flags;
.................... };
.................... 
.................... typedef struct EmbeddedCliImpl EmbeddedCliImpl;
.................... 
.................... struct AutocompletedCommand {
....................     /**
....................      * Name of autocompleted command (or first candidate for autocompletion if
....................      * there are multiple candidates).
....................      * NULL if autocomplete not possible.
....................      */
....................     char *firstCandidate;
.................... 
....................     /**
....................      * Number of characters that can be completed safely. For example, if there
....................      * are two possible commands "get-led" and "get-adc", then for prefix "g"
....................      * autocompletedLen will be 4. If there are only one candidate, this number
....................      * is always equal to length of the command.
....................      */
....................     uint16_t autocompletedLen;
.................... 
....................     /**
....................      * Total number of candidates for autocompletion
....................      */
....................     uint16_t candidateCount;
.................... };
.................... 
.................... typedef struct AutocompletedCommand AutocompletedCommand;
.................... 
.................... static EmbeddedCliConfig defaultConfig;
.................... 
.................... /**
....................  * Number of commands that cli adds. Commands:
....................  * - help
....................  */
.................... static uint16_t cliInternalBindingCount = 1;
.................... 
.................... static char *lineBreak = "\r\n";
.................... 
.................... /**
....................  * Navigate through command history back and forth. If navigateUp is true,
....................  * navigate to older commands, otherwise navigate to newer.
....................  * When history end is reached, nothing happens.
....................  * @param cli
....................  * @param navigateUp
....................  */
.................... static void navigateHistory(EmbeddedCli *cli, bool navigateUp);
.................... 
.................... /**
....................  * Process escaped character. After receiving ESC+[ sequence, all chars up to
....................  * ending character are sent to this function
....................  * @param cli
....................  * @param c
....................  */
.................... static void onEscapedInput(EmbeddedCli *cli, char c);
.................... 
.................... /**
....................  * Process input character. Character is valid displayable char and should be
....................  * added to current command string and displayed to client.
....................  * @param cli
....................  * @param c
....................  */
.................... static void onCharInput(EmbeddedCli *cli, char c);
.................... 
.................... /**
....................  * Process control character (like \r or \n) possibly altering state of current
....................  * command or executing onCommand callback.
....................  * @param cli
....................  * @param c
....................  */
.................... static void onControlInput(EmbeddedCli *cli, char c);
.................... 
.................... /**
....................  * Parse command in buffer and execute callback
....................  * @param cli
....................  */
.................... static void parseCommand(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Setup bindings for internal commands, like help
....................  * @param cli
....................  */
.................... static void initInternalBindings(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Show help for given tokens (or default help if no tokens)
....................  * @param cli
....................  * @param tokens
....................  * @param context - not used
....................  */
.................... static void onHelp(EmbeddedCli *cli, char *tokens, void *context);
.................... 
.................... /**
....................  * Show error about unknown command
....................  * @param cli
....................  * @param name
....................  */
.................... static void onUnknownCommand(EmbeddedCli *cli, char *name);
.................... 
.................... /**
....................  * Return autocompleted command for given prefix.
....................  * Prefix is compared to all known command bindings and autocompleted result
....................  * is returned
....................  * @param cli
....................  * @param prefix
....................  * @return
....................  */
.................... static AutocompletedCommand getAutocompletedCommand(EmbeddedCli *cli, char *prefix);
.................... 
.................... /**
....................  * Prints autocompletion result while keeping current command unchanged
....................  * Prints only if autocompletion is present and only one candidate exists.
....................  * @param cli
....................  */
.................... static void printLiveAutocompletion(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Handles autocomplete request. If autocomplete possible - fills current
....................  * command with autocompleted command. When multiple commands satisfy entered
....................  * prefix, they are printed to output.
....................  * @param cli
....................  */
.................... static void onAutocompleteRequest(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Removes all input from current line (replaces it with whitespaces)
....................  * And places cursor at the beginning of the line
....................  * @param cli
....................  */
.................... static void clearCurrentLine(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Write given string to cli output
....................  * @param cli
....................  * @param str
....................  */
.................... static void writeToOutput(EmbeddedCli *cli, char *str);
.................... 
.................... /**
....................  * Returns true if provided char is a supported control char:
....................  * \r, \n, \b or 0x7F (treated as \b)
....................  * @param c
....................  * @return
....................  */
.................... static bool isControlChar(char c);
.................... 
.................... /**
....................  * Returns true if provided char is a valid displayable character:
....................  * a-z, A-Z, 0-9, whitespace, punctuation, etc.
....................  * Currently only ASCII is supported
....................  * @param c
....................  * @return
....................  */
.................... static bool isDisplayableChar(char c);
.................... 
.................... /**
....................  * How many elements are currently available in buffer
....................  * @param buffer
....................  * @return number of elements
....................  */
.................... static uint16_t fifoBufAvailable(FifoBuf *buffer);
.................... 
.................... /**
....................  * Return first character from buffer and remove it from buffer
....................  * Buffer must be non-empty, otherwise 0 is returned
....................  * @param buffer
....................  * @return
....................  */
.................... static char fifoBufPop(FifoBuf *buffer);
.................... 
.................... /**
....................  * Push character into fifo buffer. If there is no space left, character is
....................  * discarded and false is returned
....................  * @param buffer
....................  * @param a - character to add
....................  * @return true if char was added to buffer, false otherwise
....................  */
.................... static bool fifoBufPush(FifoBuf *buffer, char a);
.................... 
.................... /**
....................  * Copy provided string to the history buffer.
....................  * If it is already inside history, it will be removed from it and added again.
....................  * So after addition, it will always be on top
....................  * If available size is not enough (and total size is enough) old elements will
....................  * be removed from history so this item can be put to it
....................  * @param history
....................  * @param str
....................  * @return true if string was put in history
....................  */
.................... static bool historyPut(CliHistory *history, char *str);
.................... 
.................... /**
....................  * Get item from history. Items are counted from 1 so if item is 0 or greater
....................  * than itemCount, NULL is returned
....................  * @param history
....................  * @param item
....................  * @return true if string was put in history
....................  */
.................... static char *historyGet(CliHistory *history, uint16_t item);
.................... 
.................... /**
....................  * Remove specific item from history
....................  * @param history
....................  * @param str - string to remove
....................  * @return
....................  */
.................... static void historyRemove(CliHistory *history, char *str);
.................... 
.................... /**
....................  * Return position (index of first char) of specified token
....................  * @param tokenizedStr - tokenized string (separated by \0 with
....................  * \0\0 at the end)
....................  * @param pos - token position (counted from 1)
....................  * @return index of first char of specified token
....................  */
.................... static uint16_t getTokenPosition(char *tokenizedStr, uint16_t pos);
.................... 
.................... static char defaultInvitation[] = "> ";
.................... 
.................... EmbeddedCliConfig *embeddedCliDefaultConfig(void) {
....................     defaultConfig.rxBufferSize = 64;
....................     defaultConfig.cmdBufferSize = 64;
....................     defaultConfig.historyBufferSize = 128;
....................     defaultConfig.cliBuffer = NULL;
....................     defaultConfig.cliBufferSize = 0;
....................     defaultConfig.maxBindingCount = 8;
....................     defaultConfig.enableAutoComplete = true;
....................     defaultConfig.invitation = defaultInvitation;
....................     return &defaultConfig;
.................... }
.................... 
.................... uint16_t embeddedCliRequiredSize(EmbeddedCliConfig *config) {
....................     uint16_t bindingCount = (uint16_t) (config->maxBindingCount + cliInternalBindingCount);
....................     return (uint16_t) (CLI_UINT_SIZE * (
....................             BYTES_TO_CLI_UINTS(sizeof(EmbeddedCli)) +
....................             BYTES_TO_CLI_UINTS(sizeof(EmbeddedCliImpl)) +
....................             BYTES_TO_CLI_UINTS(config->rxBufferSize * sizeof(char)) +
....................             BYTES_TO_CLI_UINTS(config->cmdBufferSize * sizeof(char)) +
....................             BYTES_TO_CLI_UINTS(config->historyBufferSize * sizeof(char)) +
....................             BYTES_TO_CLI_UINTS(bindingCount * sizeof(CliCommandBinding)) +
....................             BYTES_TO_CLI_UINTS(bindingCount * sizeof(uint8_t))));
.................... }
.................... 
.................... EmbeddedCli *embeddedCliNew(EmbeddedCliConfig *config) {
....................     EmbeddedCli *cli = NULL;
.................... 
....................     uint16_t bindingCount = (uint16_t) (config->maxBindingCount + cliInternalBindingCount);
.................... 
....................     size_t totalSize = embeddedCliRequiredSize(config);
.................... 
....................     bool allocated = false;
....................     if (config->cliBuffer == NULL) {
....................         return NULL;
....................         //config->cliBuffer = (CLI_UINT *) malloc(totalSize); // malloc guarantees alignment.
....................         //if (config->cliBuffer == NULL)
....................         //    return NULL;
....................         //allocated = true;
....................     } else if (config->cliBufferSize < totalSize) {
....................         return NULL;
....................     }
.................... 
....................     CLI_UINT *buf = config->cliBuffer;
.................... 
....................     memset(buf, 0, totalSize);
.................... 
....................     cli = (EmbeddedCli *) buf;
....................     buf += BYTES_TO_CLI_UINTS(sizeof(EmbeddedCli));
.................... 
....................     cli->_impl = (EmbeddedCliImpl *) buf;
....................     buf += BYTES_TO_CLI_UINTS(sizeof(EmbeddedCliImpl));
.................... 
....................     PREPARE_IMPL(cli);
....................     impl->rxBuffer.buf = (char *) buf;
....................     buf += BYTES_TO_CLI_UINTS(config->rxBufferSize * sizeof(char));
.................... 
....................     impl->cmdBuffer = (char *) buf;
....................     buf += BYTES_TO_CLI_UINTS(config->cmdBufferSize * sizeof(char));
.................... 
....................     impl->bindings = (CliCommandBinding *) buf;
....................     buf += BYTES_TO_CLI_UINTS(bindingCount * sizeof(CliCommandBinding));
.................... 
....................     impl->bindingsFlags = (uint8_t *) buf;
....................     buf += BYTES_TO_CLI_UINTS(bindingCount);
.................... 
....................     impl->history.buf = (char *) buf;
....................     impl->history.bufferSize = config->historyBufferSize;
.................... 
....................     if (allocated)
....................         SET_FLAG(impl->flags, CLI_FLAG_ALLOCATED);
.................... 
....................     if (config->enableAutoComplete)
....................         SET_FLAG(impl->flags, CLI_FLAG_AUTOCOMPLETE_ENABLED);
.................... 
....................     impl->rxBuffer.size = config->rxBufferSize;
....................     impl->rxBuffer.front = 0;
....................     impl->rxBuffer.back = 0;
....................     impl->cmdMaxSize = config->cmdBufferSize;
....................     impl->bindingsCount = 0;
....................     impl->maxBindingsCount = (uint16_t) (config->maxBindingCount + cliInternalBindingCount);
....................     impl->lastChar = '\0';
....................     impl->invitation = config->invitation;
.................... 
....................     initInternalBindings(cli);
.................... 
....................     return cli;
.................... }
.................... 
.................... EmbeddedCli *embeddedCliNewDefault(void) {
....................     return embeddedCliNew(embeddedCliDefaultConfig());
.................... }
.................... 
.................... void embeddedCliReceiveChar(EmbeddedCli *cli, char c) {
....................     PREPARE_IMPL(cli);
.................... 
....................     if (!fifoBufPush(&impl->rxBuffer, c)) {
....................         SET_FLAG(impl->flags, CLI_FLAG_OVERFLOW);
....................     }
.................... }
.................... 
.................... void embeddedCliProcess(EmbeddedCli *cli) {
....................     if (cli->writeChar == NULL)
....................         return;
.................... 
....................     PREPARE_IMPL(cli);
.................... 
.................... 
....................     if (!IS_FLAG_SET(impl->flags, CLI_FLAG_INIT_COMPLETE)) {
....................         SET_FLAG(impl->flags, CLI_FLAG_INIT_COMPLETE);
....................         writeToOutput(cli, impl->invitation);
....................     }
.................... 
....................     while (fifoBufAvailable(&impl->rxBuffer)) {
....................         char c = fifoBufPop(&impl->rxBuffer);
.................... 
....................         if (IS_FLAG_SET(impl->flags, CLI_FLAG_ESCAPE_MODE)) {
....................             onEscapedInput(cli, c);
....................         } else if (impl->lastChar == 0x1B && c == '[') {
....................             //enter escape mode
....................             SET_FLAG(impl->flags, CLI_FLAG_ESCAPE_MODE);
....................         } else if (isControlChar(c)) {
....................             onControlInput(cli, c);
....................         } else if (isDisplayableChar(c)) {
....................             onCharInput(cli, c);
....................         }
.................... 
....................         printLiveAutocompletion(cli);
.................... 
....................         impl->lastChar = c;
....................     }
.................... 
....................     // discard unfinished command if overflow happened
....................     if (IS_FLAG_SET(impl->flags, CLI_FLAG_OVERFLOW)) {
....................         impl->cmdSize = 0;
....................         impl->cmdBuffer[impl->cmdSize] = '\0';
....................         UNSET_U8FLAG(impl->flags, CLI_FLAG_OVERFLOW);
....................     }
.................... }
.................... 
.................... bool embeddedCliAddBinding(EmbeddedCli *cli, CliCommandBinding binding) {
....................     PREPARE_IMPL(cli);
....................     if (impl->bindingsCount == impl->maxBindingsCount)
....................         return false;
.................... 
....................     impl->bindings[impl->bindingsCount] = binding;
.................... 
....................     ++impl->bindingsCount;
....................     return true;
.................... }
.................... 
.................... void embeddedCliPrint(EmbeddedCli *cli, char *string) {
....................     if (cli->writeChar == NULL)
....................         return;
.................... 
....................     PREPARE_IMPL(cli);
.................... 
....................     // remove chars for autocompletion and live command
....................     if (!IS_FLAG_SET(impl->flags, CLI_FLAG_DIRECT_PRINT))
....................         clearCurrentLine(cli);
.................... 
....................     // print provided string
....................     writeToOutput(cli, string);
....................     writeToOutput(cli, lineBreak);
.................... 
....................     // print current command back to screen
....................     if (!IS_FLAG_SET(impl->flags, CLI_FLAG_DIRECT_PRINT)) {
....................         writeToOutput(cli, impl->invitation);
....................         writeToOutput(cli, impl->cmdBuffer);
....................         impl->inputLineLength = impl->cmdSize;
.................... 
....................         printLiveAutocompletion(cli);
....................     }
.................... }
.................... 
.................... void embeddedCliFree(EmbeddedCli *cli) {
....................     PREPARE_IMPL(cli);
....................     if (IS_FLAG_SET(impl->flags, CLI_FLAG_ALLOCATED)) {
....................         // allocation is done in single call to malloc, so need only single free
....................         //free(cli);
....................     }
.................... }
.................... 
.................... void embeddedCliTokenizeArgs(char *args) {
....................     if (args == NULL)
....................         return;
.................... 
....................     // for now only space, but can add more later
....................     char *separators = " ";
.................... 
....................     // indicates that arg is quoted so separators are copied as is
....................     bool quotesEnabled = false;
....................     // indicates that previous char was a slash, so next char is copied as is
....................     bool escapeActivated = false;
....................     int insertPos = 0;
.................... 
....................     int i = 0;
....................     char currentChar;
....................     while ((currentChar = args[i]) != '\0') {
....................         ++i;
.................... 
....................         if (escapeActivated) {
....................             escapeActivated = false;
....................         } else if (currentChar == '\\') {
....................             escapeActivated = true;
....................             continue;
....................         } else if (currentChar == '"') {
....................             quotesEnabled = !quotesEnabled;
....................             currentChar = '\0';
....................         } else if (!quotesEnabled && strchr(separators, currentChar) != NULL) {
....................             currentChar = '\0';
....................         }
.................... 
....................         // null chars are only copied once and not copied to the beginning
....................         if (currentChar != '\0' || (insertPos > 0 && args[insertPos - 1] != '\0')) {
....................             args[insertPos] = currentChar;
....................             ++insertPos;
....................         }
....................     }
.................... 
....................     // make args double null-terminated source buffer must be big enough to contain extra spaces
....................     args[insertPos] = '\0';
....................     args[insertPos + 1] = '\0';
.................... }
.................... 
.................... char *embeddedCliGetToken(char *tokenizedStr, uint16_t pos) {
....................     uint16_t i = getTokenPosition(tokenizedStr, pos);
.................... 
....................     if (i != CLI_TOKEN_NPOS)
....................         return &tokenizedStr[i];
....................     else
....................         return NULL;
.................... }
.................... 
.................... char *embeddedCliGetTokenVariable(char *tokenizedStr, uint16_t pos) {
....................     uint16_t i = getTokenPosition(tokenizedStr, pos);
.................... 
....................     if (i != CLI_TOKEN_NPOS)
....................         return &tokenizedStr[i];
....................     else
....................         return NULL;
.................... }
.................... 
.................... uint16_t embeddedCliFindToken(char *tokenizedStr, char *token) {
....................     if (tokenizedStr == NULL || token == NULL)
....................         return 0;
.................... 
....................     uint16_t size = embeddedCliGetTokenCount(tokenizedStr);
....................     for (uint16_t i = 1; i <= size; ++i) {
....................         if (strcmp(embeddedCliGetToken(tokenizedStr, i), token) == 0)
....................             return i;
....................     }
.................... 
....................     return 0;
.................... }
.................... 
.................... uint16_t embeddedCliGetTokenCount(char *tokenizedStr) {
....................     if (tokenizedStr == NULL || tokenizedStr[0] == '\0')
....................         return 0;
.................... 
....................     int i = 0;
....................     uint16_t tokenCount = 1;
....................     while (true) {
....................         if (tokenizedStr[i] == '\0') {
....................             if (tokenizedStr[i + 1] == '\0')
....................                 break;
....................             ++tokenCount;
....................         }
....................         ++i;
....................     }
.................... 
....................     return tokenCount;
.................... }
.................... 
.................... static void navigateHistory(EmbeddedCli *cli, bool navigateUp) {
....................     PREPARE_IMPL(cli);
....................     if (impl->history.itemsCount == 0 ||
....................         (navigateUp && impl->history.current == impl->history.itemsCount) ||
....................         (!navigateUp && impl->history.current == 0))
....................         return;
.................... 
....................     clearCurrentLine(cli);
.................... 
....................     writeToOutput(cli, impl->invitation);
.................... 
....................     if (navigateUp)
....................         ++impl->history.current;
....................     else
....................         --impl->history.current;
.................... 
....................     char *item = historyGet(&impl->history, impl->history.current);
....................     // simple way to handle empty command the same way as others
....................     if (item == NULL)
....................         item = "";
....................     uint16_t len = (uint16_t) strlen(item);
....................     memcpy(impl->cmdBuffer, item, len);
....................     impl->cmdBuffer[len] = '\0';
....................     impl->cmdSize = len;
.................... 
....................     writeToOutput(cli, impl->cmdBuffer);
....................     impl->inputLineLength = impl->cmdSize;
.................... 
....................     printLiveAutocompletion(cli);
.................... }
.................... 
.................... static void onEscapedInput(EmbeddedCli *cli, char c) {
....................     PREPARE_IMPL(cli);
.................... 
....................     if (c >= 64 && c <= 126) {
....................         // handle escape sequence
....................         UNSET_U8FLAG(impl->flags, CLI_FLAG_ESCAPE_MODE);
.................... 
....................         if (c == 'A' || c == 'B') {
....................             // treat \e[..A as cursor up and \e[..B as cursor down
....................             // there might be extra chars between [ and A/B, just ignore them
....................             navigateHistory(cli, c == 'A');
....................         }
....................     }
.................... }
.................... 
.................... static void onCharInput(EmbeddedCli *cli, char c) {
....................     PREPARE_IMPL(cli);
.................... 
....................     // have to reserve two extra chars for command ending (used in tokenization)
....................     if (impl->cmdSize + 2 >= impl->cmdMaxSize)
....................         return;
.................... 
....................     impl->cmdBuffer[impl->cmdSize] = c;
....................     ++impl->cmdSize;
....................     impl->cmdBuffer[impl->cmdSize] = '\0';
.................... 
....................     cli->writeChar(cli, c);
.................... }
.................... 
.................... static void onControlInput(EmbeddedCli *cli, char c) {
....................     PREPARE_IMPL(cli);
.................... 
....................     // process \r\n and \n\r as single \r\n command
....................     if ((impl->lastChar == '\r' && c == '\n') ||
....................         (impl->lastChar == '\n' && c == '\r'))
....................         return;
.................... 
....................     if (c == '\r' || c == '\n') {
....................         // try to autocomplete command and then process it
....................         onAutocompleteRequest(cli);
.................... 
....................         writeToOutput(cli, lineBreak);
.................... 
....................         if (impl->cmdSize > 0)
....................             parseCommand(cli);
....................         impl->cmdSize = 0;
....................         impl->cmdBuffer[impl->cmdSize] = '\0';
....................         impl->inputLineLength = 0;
....................         impl->history.current = 0;
.................... 
....................         writeToOutput(cli, impl->invitation);
....................     } else if ((c == '\b' || c == 0x7F) && impl->cmdSize > 0) {
....................         // remove char from screen
....................         cli->writeChar(cli, '\b');
....................         cli->writeChar(cli, ' ');
....................         cli->writeChar(cli, '\b');
....................         // and from buffer
....................         --impl->cmdSize;
....................         impl->cmdBuffer[impl->cmdSize] = '\0';
....................     } else if (c == '\t') {
....................         onAutocompleteRequest(cli);
....................     }
.................... 
.................... }
.................... 
.................... static void parseCommand(EmbeddedCli *cli) {
....................     PREPARE_IMPL(cli);
.................... 
....................     bool isEmpty = true;
.................... 
....................     for (int i = 0; i < impl->cmdSize; ++i) {
....................         if (impl->cmdBuffer[i] != ' ') {
....................             isEmpty = false;
....................             break;
....................         }
....................     }
....................     // do not process empty commands
....................     if (isEmpty)
....................         return;
....................     // push command to history before buffer is modified
....................     historyPut(&impl->history, impl->cmdBuffer);
.................... 
....................     char *cmdName = NULL;
....................     char *cmdArgs = NULL;
....................     bool nameFinished = false;
.................... 
....................     // find command name and command args inside command buffer
....................     for (int i = 0; i < impl->cmdSize; ++i) {
....................         char c = impl->cmdBuffer[i];
.................... 
....................         if (c == ' ') {
....................             // all spaces between name and args are filled with zeros
....................             // so name is a correct null-terminated string
....................             if (cmdArgs == NULL)
....................                 impl->cmdBuffer[i] = '\0';
....................             if (cmdName != NULL)
....................                 nameFinished = true;
.................... 
....................         } else if (cmdName == NULL) {
....................             cmdName = &impl->cmdBuffer[i];
....................         } else if (cmdArgs == NULL && nameFinished) {
....................             cmdArgs = &impl->cmdBuffer[i];
....................         }
....................     }
.................... 
....................     // we keep two last bytes in cmd buffer reserved so cmdSize is always by 2
....................     // less than cmdMaxSize
....................     impl->cmdBuffer[impl->cmdSize + 1] = '\0';
.................... 
....................     if (cmdName == NULL)
....................         return;
.................... 
....................     // try to find command in bindings
....................     for (int i = 0; i < impl->bindingsCount; ++i) {
....................         if (strcmp(cmdName, impl->bindings[i].name) == 0) {
....................             if (impl->bindings[i].binding == NULL)
....................                 break;
.................... 
....................             if (impl->bindings[i].tokenizeArgs)
....................                 embeddedCliTokenizeArgs(cmdArgs);
....................             // currently, output is blank line, so we can just print directly
....................             SET_FLAG(impl->flags, CLI_FLAG_DIRECT_PRINT);
....................             impl->bindings[i].binding(cli, cmdArgs, impl->bindings[i].context);
....................             UNSET_U8FLAG(impl->flags, CLI_FLAG_DIRECT_PRINT);
....................             return;
....................         }
....................     }
.................... 
....................     // command not found in bindings or binding was null
....................     // try to call default callback
....................     if (cli->onCommand != NULL) {
....................         CliCommand command;
....................         command.name = cmdName;
....................         command.args = cmdArgs;
.................... 
....................         // currently, output is blank line, so we can just print directly
....................         SET_FLAG(impl->flags, CLI_FLAG_DIRECT_PRINT);
....................         cli->onCommand(cli, &command);
....................         UNSET_U8FLAG(impl->flags, CLI_FLAG_DIRECT_PRINT);
....................     } else {
....................         onUnknownCommand(cli, cmdName);
....................     }
.................... }
.................... 
.................... static void initInternalBindings(EmbeddedCli *cli) {
....................     CliCommandBinding b = {
....................             "help",
....................             "Print list of commands",
....................             true,
....................             NULL,
....................             onHelp
....................     };
....................     embeddedCliAddBinding(cli, b);
.................... }
.................... 
.................... static void onHelp(EmbeddedCli *cli, char *tokens, void *context) {
....................     UNUSED(context);
....................     PREPARE_IMPL(cli);
.................... 
....................     if (impl->bindingsCount == 0) {
....................         char help[] = "Help is not available";
....................         writeToOutput(cli, help);
....................         writeToOutput(cli, lineBreak);
....................         return;
....................     }
.................... 
....................     uint16_t tokenCount = embeddedCliGetTokenCount(tokens);
....................     if (tokenCount == 0) {
....................         for (int i = 0; i < impl->bindingsCount; ++i) {
....................             char star[] = " * ";
....................             writeToOutput(cli, star);
....................             writeToOutput(cli, impl->bindings[i].name);
....................             writeToOutput(cli, lineBreak);
....................             if (impl->bindings[i].help != NULL) {
....................                 cli->writeChar(cli, '\t');
....................                 writeToOutput(cli, impl->bindings[i].help);
....................                 writeToOutput(cli, lineBreak);
....................             }
....................         }
....................     } else if (tokenCount == 1) {
....................         // try find command
....................         char *helpStr = NULL;
....................         char *cmdName = embeddedCliGetToken(tokens, 1);
....................         bool found = false;
....................         for (int i = 0; i < impl->bindingsCount; ++i) {
....................             if (strcmp(impl->bindings[i].name, cmdName) == 0) {
....................                 helpStr = impl->bindings[i].help;
....................                 found = true;
....................                 break;
....................             }
....................         }
....................         if (found && helpStr != NULL) {
....................             char star[] = " * ";
....................             writeToOutput(cli, star);
....................             writeToOutput(cli, cmdName);
....................             writeToOutput(cli, lineBreak);
....................             cli->writeChar(cli, '\t');
....................             writeToOutput(cli, helpStr);
....................             writeToOutput(cli, lineBreak);
....................         } else if (found) {
....................             char help[] = "Help is not available";
....................             writeToOutput(cli, help);
....................             writeToOutput(cli, lineBreak);
....................         } else {
....................             onUnknownCommand(cli, cmdName);
....................         }
....................     } else {
....................         char help[] = "Command \"help\" receives one or zero arguments";
....................         writeToOutput(cli, help);
....................         writeToOutput(cli, lineBreak);
....................     }
.................... }
.................... 
.................... static void onUnknownCommand(EmbeddedCli *cli, char *name) {
....................     char unknown[] = "Unknown command: \"";
....................     writeToOutput(cli, unknown);
....................     writeToOutput(cli, name);
....................     char help[] = "\". Write \"help\" for a list of available commands";
....................     writeToOutput(cli, help);
....................     writeToOutput(cli, lineBreak);
.................... }
.................... 
.................... static AutocompletedCommand getAutocompletedCommand(EmbeddedCli *cli, char *prefix) {
....................     AutocompletedCommand cmd = {NULL, 0, 0};
.................... 
....................     size_t prefixLen = strlen(prefix);
.................... 
....................     PREPARE_IMPL(cli);
....................     if (impl->bindingsCount == 0 || prefixLen == 0)
....................         return cmd;
.................... 
.................... 
....................     for (int i = 0; i < impl->bindingsCount; ++i) {
....................         char *name = impl->bindings[i].name;
....................         size_t len = strlen(name);
.................... 
....................         // unset autocomplete flag
....................         UNSET_U8FLAG(impl->bindingsFlags[i], BINDING_FLAG_AUTOCOMPLETE);
.................... 
....................         if (len < prefixLen)
....................             continue;
.................... 
....................         // check if this command is candidate for autocomplete
....................         bool isCandidate = true;
....................         for (size_t j = 0; j < prefixLen; ++j) {
....................             if (prefix[j] != name[j]) {
....................                 isCandidate = false;
....................                 break;
....................             }
....................         }
....................         if (!isCandidate)
....................             continue;
.................... 
....................         impl->bindingsFlags[i] |= BINDING_FLAG_AUTOCOMPLETE;
.................... 
....................         if (cmd.candidateCount == 0 || len < cmd.autocompletedLen)
....................             cmd.autocompletedLen = (uint16_t) len;
.................... 
....................         ++cmd.candidateCount;
.................... 
....................         if (cmd.candidateCount == 1) {
....................             cmd.firstCandidate = name;
....................             continue;
....................         }
.................... 
....................         for (size_t j = impl->cmdSize; j < cmd.autocompletedLen; ++j) {
....................             if (cmd.firstCandidate[j] != name[j]) {
....................                 cmd.autocompletedLen = (uint16_t) j;
....................                 break;
....................             }
....................         }
....................     }
.................... 
....................     return cmd;
.................... }
.................... 
.................... static void printLiveAutocompletion(EmbeddedCli *cli) {
....................     PREPARE_IMPL(cli);
.................... 
....................     if (!IS_FLAG_SET(impl->flags, CLI_FLAG_AUTOCOMPLETE_ENABLED))
....................         return;
.................... 
....................     AutocompletedCommand cmd = getAutocompletedCommand(cli, impl->cmdBuffer);
.................... 
....................     if (cmd.candidateCount == 0) {
....................         cmd.autocompletedLen = impl->cmdSize;
....................     }
.................... 
....................     // print live autocompletion (or nothing, if it doesn't exist)
....................     for (size_t i = impl->cmdSize; i < cmd.autocompletedLen; ++i) {
....................         cli->writeChar(cli, cmd.firstCandidate[i]);
....................     }
....................     // replace with spaces previous autocompletion
....................     for (size_t i = cmd.autocompletedLen; i < impl->inputLineLength; ++i) {
....................         cli->writeChar(cli, ' ');
....................     }
....................     impl->inputLineLength = cmd.autocompletedLen;
....................     cli->writeChar(cli, '\r');
....................     // print current command again so cursor is moved to initial place
....................     writeToOutput(cli, impl->invitation);
....................     writeToOutput(cli, impl->cmdBuffer);
.................... }
.................... 
.................... static void onAutocompleteRequest(EmbeddedCli *cli) {
....................     PREPARE_IMPL(cli);
.................... 
....................     AutocompletedCommand cmd = getAutocompletedCommand(cli, impl->cmdBuffer);
.................... 
....................     if (cmd.candidateCount == 0)
....................         return;
.................... 
....................     if (cmd.candidateCount == 1 || cmd.autocompletedLen > impl->cmdSize) {
....................         // can copy from index cmdSize, but prefix is the same, so copy everything
....................         memcpy(impl->cmdBuffer, cmd.firstCandidate, cmd.autocompletedLen);
....................         if (cmd.candidateCount == 1) {
....................             impl->cmdBuffer[cmd.autocompletedLen] = ' ';
....................             ++cmd.autocompletedLen;
....................         }
....................         impl->cmdBuffer[cmd.autocompletedLen] = '\0';
.................... 
....................         writeToOutput(cli, &impl->cmdBuffer[impl->cmdSize]);
....................         impl->cmdSize = cmd.autocompletedLen;
....................         impl->inputLineLength = impl->cmdSize;
....................         return;
....................     }
.................... 
....................     // with multiple candidates when we already completed to common prefix
....................     // we show all candidates and print input again
....................     // we need to completely clear current line since it begins with invitation
....................     clearCurrentLine(cli);
.................... 
....................     for (int i = 0; i < impl->bindingsCount; ++i) {
....................         // autocomplete flag is set for all candidates by last call to
....................         // getAutocompletedCommand
....................         if (!(impl->bindingsFlags[i] & BINDING_FLAG_AUTOCOMPLETE))
....................             continue;
.................... 
....................         char *name = impl->bindings[i].name;
.................... 
....................         writeToOutput(cli, name);
....................         writeToOutput(cli, lineBreak);
....................     }
.................... 
....................     writeToOutput(cli, impl->invitation);
....................     writeToOutput(cli, impl->cmdBuffer);
.................... 
....................     impl->inputLineLength = impl->cmdSize;
.................... }
.................... 
.................... static void clearCurrentLine(EmbeddedCli *cli) {
....................     PREPARE_IMPL(cli);
....................     size_t len = impl->inputLineLength + strlen(impl->invitation);
.................... 
....................     cli->writeChar(cli, '\r');
....................     for (size_t i = 0; i < len; ++i) {
....................         cli->writeChar(cli, ' ');
....................     }
....................     cli->writeChar(cli, '\r');
....................     impl->inputLineLength = 0;
.................... }
.................... 
.................... static void writeToOutput(EmbeddedCli *cli, char *str) {
....................     size_t len = strlen(str);
.................... 
....................     for (size_t i = 0; i < len; ++i) {
....................         cli->writeChar(cli, str[i]);
....................     }
.................... }
.................... 
.................... static bool isControlChar(char c) {
....................     return c == '\r' || c == '\n' || c == '\b' || c == '\t' || c == 0x7F;
.................... }
.................... 
.................... static bool isDisplayableChar(char c) {
....................     return (c >= 32 && c <= 126);
.................... }
.................... 
.................... static uint16_t fifoBufAvailable(FifoBuf *buffer) {
....................     if (buffer->back >= buffer->front)
....................         return (uint16_t) (buffer->back - buffer->front);
....................     else
....................         return (uint16_t) (buffer->size - buffer->front + buffer->back);
.................... }
.................... 
.................... static char fifoBufPop(FifoBuf *buffer) {
....................     char a = '\0';
....................     if (buffer->front != buffer->back) {
....................         a = buffer->buf[buffer->front];
....................         buffer->front = (uint16_t) (buffer->front + 1) % buffer->size;
....................     }
....................     return a;
.................... }
.................... 
.................... static bool fifoBufPush(FifoBuf *buffer, char a) {
....................     uint16_t newBack = (uint16_t) (buffer->back + 1) % buffer->size;
....................     if (newBack != buffer->front) {
....................         buffer->buf[buffer->back] = a;
....................         buffer->back = newBack;
....................         return true;
....................     }
....................     return false;
.................... }
.................... 
.................... static bool historyPut(CliHistory *history, char *str) {
....................     size_t len = strlen(str);
....................     // each item is ended with \0 so, need to have that much space at least
....................     if (history->bufferSize < len + 1)
....................         return false;
.................... 
....................     // remove str from history (if it's present) so we don't get duplicates
....................     historyRemove(history, str);
.................... 
....................     size_t usedSize;
....................     // remove old items if new one can't fit into buffer
....................     while (history->itemsCount > 0) {
....................         char *item = historyGet(history, history->itemsCount);
....................         size_t itemLen = strlen(item);
....................         usedSize = ((size_t) (item - history->buf)) + itemLen + 1;
.................... 
....................         size_t freeSpace = history->bufferSize - usedSize;
.................... 
....................         if (freeSpace >= len + 1)
....................             break;
.................... 
....................         // space not enough, remove last element
....................         --history->itemsCount;
....................     }
....................     if (history->itemsCount > 0) {
....................         // when history not empty, shift elements so new item is first
....................         memmove(&history->buf[len + 1], history->buf, usedSize);
....................     }
....................     memcpy(history->buf, str, len + 1);
....................     ++history->itemsCount;
.................... 
....................     return true;
.................... }
.................... 
.................... static char *historyGet(CliHistory *history, uint16_t item) {
....................     if (item == 0 || item > history->itemsCount)
....................         return NULL;
.................... 
....................     // items are stored in the same way (separated by \0 and counted from 1),
....................     // so can use this call
....................     return embeddedCliGetToken(history->buf, item);
.................... }
.................... 
.................... static void historyRemove(CliHistory *history, char *str) {
....................     if (str == NULL || history->itemsCount == 0)
....................         return;
....................     char *item = NULL;
....................     uint16_t itemPosition;
....................     for (itemPosition = 1; itemPosition <= history->itemsCount; ++itemPosition) {
....................         // items are stored in the same way (separated by \0 and counted from 1),
....................         // so can use this call
....................         item = embeddedCliGetTokenVariable(history->buf, itemPosition);
....................         if (strcmp(item, str) == 0) {
....................             break;
....................         }
....................         item = NULL;
....................     }
....................     if (item == NULL)
....................         return;
.................... 
....................     --history->itemsCount;
....................     if (itemPosition == (history->itemsCount + 1)) {
....................         // if this is a last element, nothing is remaining to move
....................         return;
....................     }
.................... 
....................     size_t len = strlen(item);
....................     size_t remaining = (size_t) (history->bufferSize - (item + len + 1 - history->buf));
....................     // move everything to the right of found item
....................     memmove(item, &item[len + 1], remaining);
.................... }
.................... 
.................... static uint16_t getTokenPosition(char *tokenizedStr, uint16_t pos) {
....................     if (tokenizedStr == NULL || pos == 0)
....................         return CLI_TOKEN_NPOS;
....................     uint16_t i = 0;
....................     uint16_t tokenCount = 1;
....................     while (true) {
....................         if (tokenCount == pos)
....................             break;
.................... 
....................         if (tokenizedStr[i] == '\0') {
....................             ++tokenCount;
....................             if (tokenizedStr[i + 1] == '\0')
....................                 break;
....................         }
.................... 
....................         ++i;
....................     }
.................... 
....................     if (tokenizedStr[i] != '\0')
....................         return i;
....................     else
....................         return CLI_TOKEN_NPOS;
.................... }
.................... #ifdef __cplusplus
.................... }
.................... #endif
.................... #endif // EMBEDDED_CLI_IMPL_GUARD
.................... #endif // EMBEDDED_CLI_IMPL
.................... 
.................... 
.................... 
.................... // eCLI Requirement
.................... void writeChar(EmbeddedCli *embeddedCli, char c);
.................... void ecli_setup();
.................... 
.................... 
.................... #define EMBEDDED_CLI_IMPL
.................... #include "embedded_cli.h"
.................... /**
....................  * This header was automatically built using
....................  * embedded_cli.h and embedded_cli.c
....................  * @date 2023-07-13
....................  *
....................  * MIT License
....................  *
....................  * Copyright (c) 2021 Sviatoslav Kokurin (funbiscuit)
....................  *
....................  * Permission is hereby granted, free of charge, to any person obtaining a copy
....................  * of this software and associated documentation files (the "Software"), to deal
....................  * in the Software without restriction, including without limitation the rights
....................  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
....................  * copies of the Software, and to permit persons to whom the Software is
....................  * furnished to do so, subject to the following conditions:
....................  *
....................  * The above copyright notice and this permission notice shall be included in all
....................  * copies or substantial portions of the Software.
....................  *
....................  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
....................  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
....................  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
....................  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
....................  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
....................  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
....................  * SOFTWARE.
....................  */
.................... #ifndef EMBEDDED_CLI_H
.................... #define EMBEDDED_CLI_H
.................... 
.................... 
.................... #ifdef __cplusplus
.................... 
.................... extern "C" {
.................... #else
.................... 
.................... #include <stdbool.h>
.................... 
.................... #endif
.................... 
.................... // cstdint is available only since C++11, so use C header
.................... #include <stdint.h>
.................... 
.................... // used for proper alignment of cli buffer
.................... #if UINTPTR_MAX == 0xFFFF
.................... #define CLI_UINT uint16_t
.................... #elif UINTPTR_MAX == 0xFFFFFFFF
.................... #define CLI_UINT uint32_t
.................... //#elif UINTPTR_MAX == 0xFFFFFFFFFFFFFFFFu
.................... //#define CLI_UINT uint64_t
.................... #else
.................... #error unsupported pointer size
.................... #endif
.................... 
.................... #define CLI_UINT_SIZE (sizeof(CLI_UINT))
.................... // convert size in bytes to size in terms of CLI_UINTs (rounded up
.................... // if bytes is not divisible by size of single CLI_UINT)
.................... #define BYTES_TO_CLI_UINTS(bytes) \
....................   (((bytes) + CLI_UINT_SIZE - 1)/CLI_UINT_SIZE)
.................... 
.................... 
.................... 
.................... struct CliCommand {
....................     /**
....................      * Name of the command.
....................      * In command "set led 1 1" "set" is name
....................      */
....................     char *name;
.................... 
....................     /**
....................      * String of arguments of the command.
....................      * In command "set led 1 1" "led 1 1" is string of arguments
....................      * Is ended with double 0x00 char
....................      * Use tokenize functions to easily get individual tokens
....................      */
....................     char *args;
.................... };
.................... 
.................... typedef struct CliCommand CliCommand;
.................... 
.................... //typedef void (*WriteCharFuncPtr)(struct EmbeddedCli *cli, char c)
.................... 
.................... struct EmbeddedCli {
....................     /**
....................      * Should write char to connection
....................      * @param cli - pointer to cli that executed this function
....................      * @param c   - actual character to write
....................      */
....................     void (*writeChar)(struct EmbeddedCli *cli, char c);
....................     //void (*writeChar)(void *cli, char c);
.................... 
....................     /**
....................      * Called when command is received and command not found in list of
....................      * command bindings (or binding function is null).
....................      * @param cli     - pointer to cli that executed this function
....................      * @param command - pointer to received command
....................      */
....................     void (*onCommand)(struct EmbeddedCli *cli, CliCommand *command);
.................... 
....................     /**
....................      * Can be used for any application context
....................      */
....................     void *appContext;
.................... 
....................     /**
....................      * Pointer to actual implementation, do not use.
....................      */
....................     void *_impl;
.................... };
.................... 
.................... typedef struct EmbeddedCli EmbeddedCli;
.................... 
.................... /**
....................  * Struct to describe binding of command to function and
....................  */
.................... struct CliCommandBinding {
....................     /**
....................      * Name of command to bind. Should not be NULL.
....................      */
....................     char *name;
.................... 
....................     /**
....................      * Help string that will be displayed when "help <cmd>" is executed.
....................      * Can have multiple lines separated with "\r\n"
....................      * Can be NULL if no help is provided.
....................      */
....................     char *help;
.................... 
....................     /**
....................      * Flag to perform tokenization before calling binding function.
....................      */
....................     bool tokenizeArgs;
.................... 
....................     /**
....................      * Pointer to any specific app context that is required for this binding.
....................      * It will be provided in binding callback.
....................      */
....................     void *context;
.................... 
....................     /**
....................      * Binding function for when command is received.
....................      * If null, default callback (onCommand) will be called.
....................      * @param cli - pointer to cli that is calling this binding
....................      * @param args - string of args (if tokenizeArgs is false) or tokens otherwise
....................      * @param context
....................      */
....................     void (*binding)(struct EmbeddedCli *cli, char *args, void *context);
.................... };
.................... 
.................... typedef struct CliCommandBinding CliCommandBinding;
.................... 
.................... /**
....................  * Configuration to create CLI
....................  */
.................... struct EmbeddedCliConfig {
....................     /**
....................      * Invitation string. Is printed at the beginning of each line with user
....................      * input
....................      */
....................     char *invitation;
....................     
....................     /**
....................      * Size of buffer that is used to store characters until they're processed
....................      */
....................     uint16_t rxBufferSize;
.................... 
....................     /**
....................      * Size of buffer that is used to store current input that is not yet
....................      * sended as command (return not pressed yet)
....................      */
....................     uint16_t cmdBufferSize;
.................... 
....................     /**
....................      * Size of buffer that is used to store previously entered commands
....................      * Only unique commands are stored in buffer. If buffer is smaller than
....................      * entered command (including arguments), command is discarded from history
....................      */
....................     uint16_t historyBufferSize;
.................... 
....................     /**
....................      * Maximum amount of bindings that can be added via addBinding function.
....................      * Cli increases takes extra bindings for internal commands:
....................      * - help
....................      */
....................     uint16_t maxBindingCount;
.................... 
....................     /**
....................      * Buffer to use for cli and all internal structures. If NULL, memory will
....................      * be allocated dynamically. Otherwise this buffer is used and no
....................      * allocations are made
....................      */
....................     CLI_UINT *cliBuffer;
.................... 
....................     /**
....................      * Size of buffer for cli and internal structures (in bytes).
....................      */
....................     uint16_t cliBufferSize;
.................... 
....................     /**
....................      * Whether autocompletion should be enabled.
....................      * If false, autocompletion is disabled but you still can use 'tab' to
....................      * complete current command manually.
....................      */
....................     bool enableAutoComplete;
.................... };
.................... 
.................... typedef struct EmbeddedCliConfig EmbeddedCliConfig;
.................... 
.................... /**
....................  * Returns pointer to default configuration for cli creation. It is safe to
....................  * modify it and then send to embeddedCliNew().
....................  * Returned structure is always the same so do not free and try to use it
....................  * immediately.
....................  * Default values:
....................  * <ul>
....................  * <li>rxBufferSize = 64</li>
....................  * <li>cmdBufferSize = 64</li>
....................  * <li>historyBufferSize = 128</li>
....................  * <li>cliBuffer = NULL (use dynamic allocation)</li>
....................  * <li>cliBufferSize = 0</li>
....................  * <li>maxBindingCount = 8</li>
....................  * <li>enableAutoComplete = true</li>
....................  * </ul>
....................  * @return configuration for cli creation
....................  */
.................... EmbeddedCliConfig *embeddedCliDefaultConfig(void);
.................... 
.................... /**
....................  * Returns how many space in config buffer is required for cli creation
....................  * If you provide buffer with less space, embeddedCliNew will return NULL
....................  * This amount will always be divisible by CLI_UINT_SIZE so allocated buffer
....................  * and internal structures can be properly aligned
....................  * @param config
....................  * @return
....................  */
.................... uint16_t embeddedCliRequiredSize(EmbeddedCliConfig *config);
.................... 
.................... /**
....................  * Create new CLI.
....................  * Memory is allocated dynamically if cliBuffer in config is NULL.
....................  * After CLI is created, override function pointers to start using it
....................  * @param config - config for cli creation
....................  * @return pointer to created CLI
....................  */
.................... EmbeddedCli *embeddedCliNew(EmbeddedCliConfig *config);
.................... 
.................... /**
....................  * Same as calling embeddedCliNew with default config.
....................  * @return
....................  */
.................... EmbeddedCli *embeddedCliNewDefault(void);
.................... 
.................... /**
....................  * Receive character and put it to internal buffer
....................  * Actual processing is done inside embeddedCliProcess
....................  * You can call this function from something like interrupt service routine,
....................  * just make sure that you call it only from single place. Otherwise input
....................  * might get corrupted
....................  * @param cli
....................  * @param c   - received char
....................  */
.................... void embeddedCliReceiveChar(EmbeddedCli *cli, char c);
.................... 
.................... /**
....................  * Process rx/tx buffers. Command callbacks are called from here
....................  * @param cli
....................  */
.................... void embeddedCliProcess(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Add specified binding to list of bindings. If list is already full, binding
....................  * is not added and false is returned
....................  * @param cli
....................  * @param binding
....................  * @return true if binding was added, false otherwise
....................  */
.................... bool embeddedCliAddBinding(EmbeddedCli *cli, CliCommandBinding binding);
.................... 
.................... /**
....................  * Print specified string and account for currently entered but not submitted
....................  * command.
....................  * Current command is deleted, provided string is printed (with new line) after
....................  * that current command is printed again, so user can continue typing it.
....................  * @param cli
....................  * @param string
....................  */
.................... void embeddedCliPrint(EmbeddedCli *cli, char *string);
.................... 
.................... /**
....................  * Free allocated for cli memory
....................  * @param cli
....................  */
.................... void embeddedCliFree(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Perform tokenization of arguments string. Original string is modified and
....................  * should not be used directly (only inside other token functions).
....................  * Individual tokens are separated by single 0x00 char, double 0x00 is put at
....................  * the end of token list. After calling this function, you can use other
....................  * token functions to get individual tokens and token count.
....................  *
....................  * Important: Call this function only once. Otherwise information will be lost if
....................  * more than one token existed
....................  * @param args - string to tokenize (must have extra writable char after 0x00)
....................  * @return
....................  */
.................... void embeddedCliTokenizeArgs(char *args);
.................... 
.................... /**
....................  * Return specific token from tokenized string
....................  * @param tokenizedStr
....................  * @param pos (counted from 1)
....................  * @return token
....................  */
.................... char *embeddedCliGetToken(char *tokenizedStr, uint16_t pos);
.................... 
.................... /**
....................  * Same as embeddedCliGetToken but works on non-buffer
....................  * @param tokenizedStr
....................  * @param pos (counted from 1)
....................  * @return token
....................  */
.................... char *embeddedCliGetTokenVariable(char *tokenizedStr, uint16_t pos);
.................... 
.................... /**
....................  * Find token in provided tokens string and return its position (counted from 1)
....................  * If no such token is found - 0 is returned.
....................  * @param tokenizedStr
....................  * @param token - token to find
....................  * @return position (increased by 1) or zero if no such token found
....................  */
.................... uint16_t embeddedCliFindToken(char *tokenizedStr, char *token);
.................... 
.................... /**
....................  * Return number of tokens in tokenized string
....................  * @param tokenizedStr
....................  * @return number of tokens
....................  */
.................... uint16_t embeddedCliGetTokenCount(char *tokenizedStr);
.................... 
.................... #ifdef __cplusplus
.................... }
.................... #endif
.................... 
.................... 
.................... #endif //EMBEDDED_CLI_H
.................... 
.................... 
.................... #ifdef EMBEDDED_CLI_IMPL
.................... #ifndef EMBEDDED_CLI_IMPL_GUARD
.................... #define EMBEDDED_CLI_IMPL_GUARD
.................... #ifdef __cplusplus
.................... extern "C" {
.................... #endif
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
*
01664:  MOVFF  572,578
01668:  MOVFF  571,577
....................    sc2=s2;
0166C:  MOVFF  574,57A
01670:  MOVFF  573,579
....................    if(sc2<sc1 && sc1 <sc2 +n)
01674:  MOVLB  5
01676:  MOVF   x7A,W
01678:  SUBWF  x78,W
0167A:  BNC   16F8
0167C:  BNZ   1684
0167E:  MOVF   x77,W
01680:  SUBWF  x79,W
01682:  BC    16F8
01684:  MOVF   x75,W
01686:  ADDWF  x79,W
01688:  MOVWF  501
0168A:  MOVF   x76,W
0168C:  ADDWFC x7A,W
0168E:  MOVWF  503
01690:  MOVF   x78,W
01692:  SUBWF  503,W
01694:  BNC   16F8
01696:  BNZ   169E
01698:  MOVF   501,W
0169A:  SUBWF  x77,W
0169C:  BC    16F8
....................       for(sc1+=n,sc2+=n;0<n;--n)
0169E:  MOVF   x75,W
016A0:  ADDWF  x77,F
016A2:  MOVF   x76,W
016A4:  ADDWFC x78,F
016A6:  MOVF   x75,W
016A8:  ADDWF  x79,F
016AA:  MOVF   x76,W
016AC:  ADDWFC x7A,F
016AE:  MOVF   x76,F
016B0:  BNZ   16B8
016B2:  MOVF   x75,W
016B4:  SUBLW  00
016B6:  BC    16F6
....................          *--sc1=*--sc2;
016B8:  MOVF   x77,W
016BA:  BTFSC  4D8.2
016BC:  DECF   x78,F
016BE:  DECF   x77,F
016C0:  MOVFF  577,57B
016C4:  MOVFF  578,57C
016C8:  MOVF   x79,W
016CA:  BTFSC  4D8.2
016CC:  DECF   x7A,F
016CE:  DECF   x79,F
016D0:  MOVFF  57A,503
016D4:  MOVFF  579,4E9
016D8:  MOVFF  57A,4EA
016DC:  MOVFF  4EF,57D
016E0:  MOVFF  578,4EA
016E4:  MOVFF  577,4E9
016E8:  MOVFF  57D,4EF
016EC:  MOVF   x75,W
016EE:  BTFSC  4D8.2
016F0:  DECF   x76,F
016F2:  DECF   x75,F
016F4:  BRA    16AE
016F6:  BRA    1738
....................    else
....................       for(;0<n;--n)
016F8:  MOVF   x76,F
016FA:  BNZ   1702
016FC:  MOVF   x75,W
016FE:  SUBLW  00
01700:  BC    1738
....................          *sc1++=*sc2++;
01702:  MOVFF  578,57C
01706:  MOVF   x77,W
01708:  INCF   x77,F
0170A:  BTFSC  4D8.2
0170C:  INCF   x78,F
0170E:  MOVWF  x7B
01710:  MOVFF  57A,4EA
01714:  MOVF   x79,W
01716:  INCF   x79,F
01718:  BTFSC  4D8.2
0171A:  INCF   x7A,F
0171C:  MOVWF  4E9
0171E:  MOVFF  4EF,57D
01722:  MOVFF  57C,4EA
01726:  MOVFF  57B,4E9
0172A:  MOVFF  57D,4EF
0172E:  MOVF   x75,W
01730:  BTFSC  4D8.2
01732:  DECF   x76,F
01734:  DECF   x75,F
01736:  BRA    16F8
....................   return s1;
01738:  MOVFF  571,501
0173C:  MOVFF  572,502
01740:  MOVLB  0
01742:  RETURN 0
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
015EC:  MOVLB  5
015EE:  MOVFF  5D0,4E9
015F2:  MOVFF  5D1,4EA
015F6:  MOVFF  4EF,5D4
015FA:  MOVFF  5D3,503
015FE:  MOVFF  5D2,4E9
01602:  MOVFF  5D3,4EA
01606:  MOVF   4EF,W
01608:  SUBWF  xD4,W
0160A:  BNZ   1636
....................       if (*s1 == '\0')
0160C:  MOVFF  5D1,503
01610:  MOVFF  5D0,4E9
01614:  MOVFF  503,4EA
01618:  MOVF   4EF,F
0161A:  BNZ   1622
....................          return(0);
0161C:  MOVLW  00
0161E:  MOVWF  501
01620:  BRA    1660
01622:  MOVFF  5D1,503
01626:  MOVF   xD0,W
01628:  INCF   xD0,F
0162A:  BTFSC  4D8.2
0162C:  INCF   xD1,F
0162E:  INCF   xD2,F
01630:  BTFSC  4D8.2
01632:  INCF   xD3,F
01634:  BRA    15EE
....................    return((*s1 < *s2) ? -1: 1);
01636:  MOVFF  5D1,503
0163A:  MOVFF  5D0,4E9
0163E:  MOVFF  5D1,4EA
01642:  MOVFF  4EF,5D4
01646:  MOVFF  5D3,503
0164A:  MOVFF  5D2,4E9
0164E:  MOVFF  5D3,4EA
01652:  MOVF   4EF,W
01654:  SUBWF  xD4,W
01656:  BC    165C
01658:  MOVLW  FF
0165A:  BRA    165E
0165C:  MOVLW  01
0165E:  MOVWF  501
01660:  MOVLB  0
01662:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
*
01B16:  MOVFF  55A,503
01B1A:  MOVFF  559,4E9
01B1E:  MOVFF  55A,4EA
01B22:  MOVF   55B,W
01B24:  SUBWF  4EF,W
01B26:  BZ    1B48
....................       if (*s == '\0')
01B28:  MOVFF  55A,503
01B2C:  MOVFF  559,4E9
01B30:  MOVFF  55A,4EA
01B34:  MOVF   4EF,F
01B36:  BNZ   1B40
....................          return(0);
01B38:  MOVLW  00
01B3A:  MOVWF  501
01B3C:  MOVWF  502
01B3E:  BRA    1B50
01B40:  INCF   559,F
01B42:  BTFSC  4D8.2
01B44:  INCF   55A,F
01B46:  BRA    1B16
....................    return(s);
01B48:  MOVFF  559,501
01B4C:  MOVFF  55A,502
01B50:  GOTO   1BBC (RETURN)
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
00768:  MOVFF  61B,61D
0076C:  MOVFF  61A,61C
00770:  MOVFF  61D,4EA
00774:  MOVLB  6
00776:  MOVFF  61C,4E9
0077A:  MOVF   4EF,F
0077C:  BZ    078A
0077E:  INCF   x1C,F
00780:  BTFSC  4D8.2
00782:  INCF   x1D,F
00784:  MOVLB  0
00786:  BRA    0770
00788:  MOVLB  6
....................    return(sc - s);
0078A:  MOVF   x1A,W
0078C:  SUBWF  x1C,W
0078E:  MOVWF  500
00790:  MOVF   x1B,W
00792:  SUBWFB x1D,W
00794:  MOVWF  503
00796:  MOVFF  500,501
0079A:  MOVWF  502
0079C:  MOVLB  0
0079E:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #define CLI_TOKEN_NPOS 0xffff
.................... 
.................... #ifndef UNUSED
.................... #define UNUSED(x) (void)x
.................... #endif
.................... 
.................... #define PREPARE_IMPL(t) \
....................   EmbeddedCliImpl* impl = (EmbeddedCliImpl*)t->_impl
.................... 
.................... #define IS_FLAG_SET(flags, flag) (((flags) & (flag)) != 0)
.................... 
.................... #define SET_FLAG(flags, flag) ((flags) |= (flag))
.................... 
.................... #define UNSET_U8FLAG(flags, flag) ((flags) &= (uint8_t) ~(flag))
.................... 
.................... /**
....................  * Marks binding as candidate for autocompletion
....................  * This flag is updated each time getAutocompletedCommand is called
....................  */
.................... #define BINDING_FLAG_AUTOCOMPLETE 1u
.................... 
.................... /**
....................  * Indicates that rx buffer overflow happened. In such case last command
....................  * that wasn't finished (no \r or \n were received) will be discarded
....................  */
.................... #define CLI_FLAG_OVERFLOW 0x01u
.................... 
.................... /**
....................  * Indicates that initialization is completed. Initialization is completed in
....................  * first call to process and needed, for example, to print invitation message.
....................  */
.................... #define CLI_FLAG_INIT_COMPLETE 0x02u
.................... 
.................... /**
....................  * Indicates that CLI structure and internal structures were allocated with
....................  * malloc and should bre freed
....................  */
.................... #define CLI_FLAG_ALLOCATED 0x04u
.................... 
.................... /**
....................  * Indicates that CLI structure and internal structures were allocated with
....................  * malloc and should bre freed
....................  */
.................... #define CLI_FLAG_ESCAPE_MODE 0x08u
.................... 
.................... /**
....................  * Indicates that CLI in mode when it will print directly to output without
....................  * clear of current command and printing it back
....................  */
.................... #define CLI_FLAG_DIRECT_PRINT 0x10u
.................... 
.................... /**
....................  * Indicates that live autocompletion is enabled
....................  */
.................... #define CLI_FLAG_AUTOCOMPLETE_ENABLED 0x20u
.................... 
.................... 
.................... struct FifoBuf {
....................     char *buf;
....................     /**
....................      * Position of first element in buffer. From this position elements are taken
....................      */
....................     uint16_t front;
....................     /**
....................      * Position after last element. At this position new elements are inserted
....................      */
....................     uint16_t back;
....................     /**
....................      * Size of buffer
....................      */
....................     uint16_t size;
.................... };
.................... 
.................... typedef struct FifoBuf FifoBuf;
.................... 
.................... struct CliHistory {
....................     /**
....................      * Items in buffer are separated by null-chars
....................      */
....................     char *buf;
.................... 
....................     /**
....................      * Total size of buffer
....................      */
....................     uint16_t bufferSize;
.................... 
....................     /**
....................      * Index of currently selected element. This allows to navigate history
....................      * After command is sent, current element is reset to 0 (no element)
....................      */
....................     uint16_t current;
.................... 
....................     /**
....................      * Number of items in buffer
....................      * Items are counted from top to bottom (and are 1 based).
....................      * So the most recent item is 1 and the oldest is itemCount.
....................      */
....................     uint16_t itemsCount;
.................... };
.................... 
.................... typedef struct CliHistory CliHistory;
.................... 
.................... struct EmbeddedCliImpl {
....................     /**
....................      * Invitation string. Is printed at the beginning of each line with user
....................      * input
....................      */
....................     char *invitation;
.................... 
....................     CliHistory history;
.................... 
....................     /**
....................      * Buffer for storing received chars.
....................      * Chars are stored in FIFO mode.
....................      */
....................     FifoBuf rxBuffer;
.................... 
....................     /**
....................      * Buffer for current command
....................      */
....................     char *cmdBuffer;
.................... 
....................     /**
....................      * Size of current command
....................      */
....................     uint16_t cmdSize;
.................... 
....................     /**
....................      * Total size of command buffer
....................      */
....................     uint16_t cmdMaxSize;
.................... 
....................     CliCommandBinding *bindings;
.................... 
....................     /**
....................      * Flags for each binding. Sizes are the same as for bindings array
....................      */
....................     uint8_t *bindingsFlags;
.................... 
....................     uint16_t bindingsCount;
.................... 
....................     uint16_t maxBindingsCount;
.................... 
....................     /**
....................      * Total length of input line. This doesn't include invitation but
....................      * includes current command and its live autocompletion
....................      */
....................     uint16_t inputLineLength;
.................... 
....................     /**
....................      * Stores last character that was processed.
....................      */
....................     char lastChar;
.................... 
....................     /**
....................      * Flags are defined as CLI_FLAG_*
....................      */
....................     uint8_t flags;
.................... };
.................... 
.................... typedef struct EmbeddedCliImpl EmbeddedCliImpl;
.................... 
.................... struct AutocompletedCommand {
....................     /**
....................      * Name of autocompleted command (or first candidate for autocompletion if
....................      * there are multiple candidates).
....................      * NULL if autocomplete not possible.
....................      */
....................     char *firstCandidate;
.................... 
....................     /**
....................      * Number of characters that can be completed safely. For example, if there
....................      * are two possible commands "get-led" and "get-adc", then for prefix "g"
....................      * autocompletedLen will be 4. If there are only one candidate, this number
....................      * is always equal to length of the command.
....................      */
....................     uint16_t autocompletedLen;
.................... 
....................     /**
....................      * Total number of candidates for autocompletion
....................      */
....................     uint16_t candidateCount;
.................... };
.................... 
.................... typedef struct AutocompletedCommand AutocompletedCommand;
.................... 
.................... static EmbeddedCliConfig defaultConfig;
.................... 
.................... /**
....................  * Number of commands that cli adds. Commands:
....................  * - help
....................  */
.................... static uint16_t cliInternalBindingCount = 1;
.................... 
.................... static char *lineBreak = "\r\n";
.................... 
.................... /**
....................  * Navigate through command history back and forth. If navigateUp is true,
....................  * navigate to older commands, otherwise navigate to newer.
....................  * When history end is reached, nothing happens.
....................  * @param cli
....................  * @param navigateUp
....................  */
.................... static void navigateHistory(EmbeddedCli *cli, bool navigateUp);
.................... 
.................... /**
....................  * Process escaped character. After receiving ESC+[ sequence, all chars up to
....................  * ending character are sent to this function
....................  * @param cli
....................  * @param c
....................  */
.................... static void onEscapedInput(EmbeddedCli *cli, char c);
.................... 
.................... /**
....................  * Process input character. Character is valid displayable char and should be
....................  * added to current command string and displayed to client.
....................  * @param cli
....................  * @param c
....................  */
.................... static void onCharInput(EmbeddedCli *cli, char c);
.................... 
.................... /**
....................  * Process control character (like \r or \n) possibly altering state of current
....................  * command or executing onCommand callback.
....................  * @param cli
....................  * @param c
....................  */
.................... static void onControlInput(EmbeddedCli *cli, char c);
.................... 
.................... /**
....................  * Parse command in buffer and execute callback
....................  * @param cli
....................  */
.................... static void parseCommand(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Setup bindings for internal commands, like help
....................  * @param cli
....................  */
.................... static void initInternalBindings(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Show help for given tokens (or default help if no tokens)
....................  * @param cli
....................  * @param tokens
....................  * @param context - not used
....................  */
.................... static void onHelp(EmbeddedCli *cli, char *tokens, void *context);
.................... 
.................... /**
....................  * Show error about unknown command
....................  * @param cli
....................  * @param name
....................  */
.................... static void onUnknownCommand(EmbeddedCli *cli, char *name);
.................... 
.................... /**
....................  * Return autocompleted command for given prefix.
....................  * Prefix is compared to all known command bindings and autocompleted result
....................  * is returned
....................  * @param cli
....................  * @param prefix
....................  * @return
....................  */
.................... static AutocompletedCommand getAutocompletedCommand(EmbeddedCli *cli, char *prefix);
.................... 
.................... /**
....................  * Prints autocompletion result while keeping current command unchanged
....................  * Prints only if autocompletion is present and only one candidate exists.
....................  * @param cli
....................  */
.................... static void printLiveAutocompletion(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Handles autocomplete request. If autocomplete possible - fills current
....................  * command with autocompleted command. When multiple commands satisfy entered
....................  * prefix, they are printed to output.
....................  * @param cli
....................  */
.................... static void onAutocompleteRequest(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Removes all input from current line (replaces it with whitespaces)
....................  * And places cursor at the beginning of the line
....................  * @param cli
....................  */
.................... static void clearCurrentLine(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Write given string to cli output
....................  * @param cli
....................  * @param str
....................  */
.................... static void writeToOutput(EmbeddedCli *cli, char *str);
.................... 
.................... /**
....................  * Returns true if provided char is a supported control char:
....................  * \r, \n, \b or 0x7F (treated as \b)
....................  * @param c
....................  * @return
....................  */
.................... static bool isControlChar(char c);
.................... 
.................... /**
....................  * Returns true if provided char is a valid displayable character:
....................  * a-z, A-Z, 0-9, whitespace, punctuation, etc.
....................  * Currently only ASCII is supported
....................  * @param c
....................  * @return
....................  */
.................... static bool isDisplayableChar(char c);
.................... 
.................... /**
....................  * How many elements are currently available in buffer
....................  * @param buffer
....................  * @return number of elements
....................  */
.................... static uint16_t fifoBufAvailable(FifoBuf *buffer);
.................... 
.................... /**
....................  * Return first character from buffer and remove it from buffer
....................  * Buffer must be non-empty, otherwise 0 is returned
....................  * @param buffer
....................  * @return
....................  */
.................... static char fifoBufPop(FifoBuf *buffer);
.................... 
.................... /**
....................  * Push character into fifo buffer. If there is no space left, character is
....................  * discarded and false is returned
....................  * @param buffer
....................  * @param a - character to add
....................  * @return true if char was added to buffer, false otherwise
....................  */
.................... static bool fifoBufPush(FifoBuf *buffer, char a);
.................... 
.................... /**
....................  * Copy provided string to the history buffer.
....................  * If it is already inside history, it will be removed from it and added again.
....................  * So after addition, it will always be on top
....................  * If available size is not enough (and total size is enough) old elements will
....................  * be removed from history so this item can be put to it
....................  * @param history
....................  * @param str
....................  * @return true if string was put in history
....................  */
.................... static bool historyPut(CliHistory *history, char *str);
.................... 
.................... /**
....................  * Get item from history. Items are counted from 1 so if item is 0 or greater
....................  * than itemCount, NULL is returned
....................  * @param history
....................  * @param item
....................  * @return true if string was put in history
....................  */
.................... static char *historyGet(CliHistory *history, uint16_t item);
.................... 
.................... /**
....................  * Remove specific item from history
....................  * @param history
....................  * @param str - string to remove
....................  * @return
....................  */
.................... static void historyRemove(CliHistory *history, char *str);
.................... 
.................... /**
....................  * Return position (index of first char) of specified token
....................  * @param tokenizedStr - tokenized string (separated by \0 with
....................  * \0\0 at the end)
....................  * @param pos - token position (counted from 1)
....................  * @return index of first char of specified token
....................  */
.................... static uint16_t getTokenPosition(char *tokenizedStr, uint16_t pos);
.................... 
.................... static char defaultInvitation[] = "> ";
.................... 
.................... EmbeddedCliConfig *embeddedCliDefaultConfig(void) {
....................     defaultConfig.rxBufferSize = 64;
*
00018:  CLRF   50D
0001A:  MOVLW  40
0001C:  MOVWF  50C
....................     defaultConfig.cmdBufferSize = 64;
0001E:  CLRF   50F
00020:  MOVWF  50E
....................     defaultConfig.historyBufferSize = 128;
00022:  CLRF   511
00024:  MOVLW  80
00026:  MOVWF  510
....................     defaultConfig.cliBuffer = NULL;
00028:  CLRF   515
0002A:  CLRF   514
....................     defaultConfig.cliBufferSize = 0;
0002C:  CLRF   517
0002E:  CLRF   516
....................     defaultConfig.maxBindingCount = 8;
00030:  CLRF   513
00032:  MOVLW  08
00034:  MOVWF  512
....................     defaultConfig.enableAutoComplete = true;
00036:  BSF    518.0
....................     defaultConfig.invitation = defaultInvitation;
00038:  MOVLW  05
0003A:  MOVWF  50B
0003C:  MOVLW  20
0003E:  MOVWF  50A
....................     return &defaultConfig;
00040:  MOVLW  0A
00042:  MOVWF  501
00044:  MOVLW  05
00046:  MOVWF  502
00048:  RETURN 0
.................... }
.................... 
.................... uint16_t embeddedCliRequiredSize(EmbeddedCliConfig *config) {
*
0006C:  MOVLW  08
0006E:  ADDWF  543,W
00070:  MOVWF  4E9
00072:  MOVLW  00
00074:  ADDWFC 544,W
00076:  MOVWF  4EA
00078:  MOVFF  4EC,548
0007C:  MOVF   4ED,F
0007E:  MOVFF  4EF,547
00082:  MOVF   519,W
00084:  ADDWF  547,W
00086:  MOVWF  545
00088:  MOVF   51A,W
0008A:  ADDWFC 548,W
0008C:  MOVWF  546
....................     uint16_t bindingCount = (uint16_t) (config->maxBindingCount + cliInternalBindingCount);
....................     return (uint16_t) (CLI_UINT_SIZE * (
....................             BYTES_TO_CLI_UINTS(sizeof(EmbeddedCli)) +
....................             BYTES_TO_CLI_UINTS(sizeof(EmbeddedCliImpl)) +
....................             BYTES_TO_CLI_UINTS(config->rxBufferSize * sizeof(char)) +
....................             BYTES_TO_CLI_UINTS(config->cmdBufferSize * sizeof(char)) +
....................             BYTES_TO_CLI_UINTS(config->historyBufferSize * sizeof(char)) +
....................             BYTES_TO_CLI_UINTS(bindingCount * sizeof(CliCommandBinding)) +
....................             BYTES_TO_CLI_UINTS(bindingCount * sizeof(uint8_t))));
0008E:  MOVLW  02
00090:  ADDWF  543,W
00092:  MOVWF  4E9
00094:  MOVLW  00
00096:  ADDWFC 544,W
00098:  MOVWF  4EA
0009A:  MOVFF  4EC,548
0009E:  MOVF   4ED,F
000A0:  MOVFF  4EF,547
000A4:  MOVLW  02
000A6:  ADDWF  547,F
000A8:  MOVLW  00
000AA:  ADDWFC 548,F
000AC:  MOVLW  01
000AE:  SUBWF  547,F
000B0:  MOVLW  00
000B2:  SUBWFB 548,F
000B4:  BCF    4D8.0
000B6:  RRCF   548,W
000B8:  MOVWF  503
000BA:  RRCF   547,W
000BC:  MOVWF  502
000BE:  ADDLW  18
000C0:  MOVWF  547
000C2:  MOVLW  00
000C4:  ADDWFC 503,W
000C6:  MOVWF  548
000C8:  MOVLW  04
000CA:  ADDWF  543,W
000CC:  MOVWF  4E9
000CE:  MOVLW  00
000D0:  ADDWFC 544,W
000D2:  MOVWF  4EA
000D4:  MOVFF  4EC,54A
000D8:  MOVF   4ED,F
000DA:  MOVFF  4EF,549
000DE:  MOVLW  02
000E0:  ADDWF  549,F
000E2:  MOVLW  00
000E4:  ADDWFC 54A,F
000E6:  MOVLW  01
000E8:  SUBWF  549,F
000EA:  MOVLW  00
000EC:  SUBWFB 54A,F
000EE:  BCF    4D8.0
000F0:  RRCF   54A,W
000F2:  MOVWF  503
000F4:  RRCF   549,W
000F6:  MOVWF  502
000F8:  ADDWF  547,F
000FA:  MOVF   503,W
000FC:  ADDWFC 548,F
000FE:  MOVLW  06
00100:  ADDWF  543,W
00102:  MOVWF  4E9
00104:  MOVLW  00
00106:  ADDWFC 544,W
00108:  MOVWF  4EA
0010A:  MOVFF  4EC,54A
0010E:  MOVF   4ED,F
00110:  MOVFF  4EF,549
00114:  MOVLW  02
00116:  ADDWF  549,F
00118:  MOVLW  00
0011A:  ADDWFC 54A,F
0011C:  MOVLW  01
0011E:  SUBWF  549,F
00120:  MOVLW  00
00122:  SUBWFB 54A,F
00124:  BCF    4D8.0
00126:  RRCF   54A,W
00128:  MOVWF  503
0012A:  RRCF   549,W
0012C:  MOVWF  502
0012E:  ADDWF  547,F
00130:  MOVF   503,W
00132:  ADDWFC 548,F
00134:  MOVFF  546,5CD
00138:  MOVFF  545,5CC
0013C:  MOVLB  5
0013E:  CLRF   xCF
00140:  MOVLW  0B
00142:  MOVWF  xCE
00144:  MOVLB  0
00146:  RCALL  004A
00148:  MOVFF  502,54A
0014C:  MOVFF  501,549
00150:  MOVLW  02
00152:  ADDWF  549,F
00154:  MOVLW  00
00156:  ADDWFC 54A,F
00158:  MOVLW  01
0015A:  SUBWF  549,F
0015C:  MOVLW  00
0015E:  SUBWFB 54A,F
00160:  BCF    4D8.0
00162:  RRCF   54A,W
00164:  MOVWF  503
00166:  RRCF   549,W
00168:  MOVWF  502
0016A:  ADDWF  547,F
0016C:  MOVF   503,W
0016E:  ADDWFC 548,F
00170:  MOVLW  02
00172:  ADDWF  545,W
00174:  MOVWF  549
00176:  MOVLW  00
00178:  ADDWFC 546,W
0017A:  MOVWF  54A
0017C:  MOVLW  01
0017E:  SUBWF  549,F
00180:  MOVLW  00
00182:  SUBWFB 54A,F
00184:  BCF    4D8.0
00186:  RRCF   54A,W
00188:  MOVWF  503
0018A:  RRCF   549,W
0018C:  MOVWF  502
0018E:  ADDWF  547,W
00190:  MOVWF  501
00192:  MOVF   548,W
00194:  ADDWFC 503,F
00196:  MOVFF  501,502
0019A:  BCF    4D8.0
0019C:  RLCF   502,F
0019E:  RLCF   503,F
001A0:  MOVFF  502,501
001A4:  MOVFF  503,502
001A8:  GOTO   0390 (RETURN)
.................... }
.................... 
.................... EmbeddedCli *embeddedCliNew(EmbeddedCliConfig *config) {
*
00360:  CLRF   539
00362:  CLRF   538
00364:  MOVLW  08
00366:  ADDWF  536,W
00368:  MOVWF  4E9
0036A:  MOVLW  00
0036C:  ADDWFC 537,W
0036E:  MOVWF  4EA
00370:  MOVFF  4EC,544
00374:  MOVF   4ED,F
00376:  MOVFF  4EF,543
0037A:  MOVF   519,W
0037C:  ADDWF  543,W
0037E:  MOVWF  53A
00380:  MOVF   51A,W
00382:  ADDWFC 544,W
00384:  MOVWF  53B
00386:  MOVFF  537,544
0038A:  MOVFF  536,543
0038E:  BRA    006C
00390:  MOVFF  502,53D
00394:  MOVFF  501,53C
00398:  BCF    53E.0
....................     EmbeddedCli *cli = NULL;
.................... 
....................     uint16_t bindingCount = (uint16_t) (config->maxBindingCount + cliInternalBindingCount);
.................... 
....................     size_t totalSize = embeddedCliRequiredSize(config);
.................... 
....................     bool allocated = false;
....................     if (config->cliBuffer == NULL) {
0039A:  MOVLW  0A
0039C:  ADDWF  536,W
0039E:  MOVWF  4E9
003A0:  MOVLW  00
003A2:  ADDWFC 537,W
003A4:  MOVWF  4EA
003A6:  MOVFF  4EC,544
003AA:  MOVF   4ED,F
003AC:  MOVFF  4EF,543
003B0:  MOVF   543,F
003B2:  BNZ   03C2
003B4:  MOVF   544,F
003B6:  BNZ   03C2
....................         return NULL;
003B8:  MOVLW  00
003BA:  MOVWF  501
003BC:  MOVWF  502
003BE:  BRA    074A
....................         //config->cliBuffer = (CLI_UINT *) malloc(totalSize); // malloc guarantees alignment.
....................         //if (config->cliBuffer == NULL)
....................         //    return NULL;
....................         //allocated = true;
....................     } else if (config->cliBufferSize < totalSize) {
003C0:  BRA    03EE
003C2:  MOVLW  0C
003C4:  ADDWF  536,W
003C6:  MOVWF  4E9
003C8:  MOVLW  00
003CA:  ADDWFC 537,W
003CC:  MOVWF  4EA
003CE:  MOVFF  4EC,544
003D2:  MOVF   4ED,F
003D4:  MOVFF  4EF,543
003D8:  MOVF   544,W
003DA:  SUBWF  53D,W
003DC:  BNC   03EE
003DE:  BNZ   03E6
003E0:  MOVF   53C,W
003E2:  SUBWF  543,W
003E4:  BC    03EE
....................         return NULL;
003E6:  MOVLW  00
003E8:  MOVWF  501
003EA:  MOVWF  502
003EC:  BRA    074A
....................     }
.................... 
....................     CLI_UINT *buf = config->cliBuffer;
003EE:  MOVLW  0A
003F0:  ADDWF  536,W
003F2:  MOVWF  4E9
003F4:  MOVLW  00
003F6:  ADDWFC 537,W
003F8:  MOVWF  4EA
003FA:  MOVFF  4EC,540
003FE:  MOVF   4ED,F
00400:  MOVFF  4EF,53F
.................... 
....................     memset(buf, 0, totalSize);
00404:  MOVFF  540,4EA
00408:  MOVFF  53F,4E9
0040C:  CLRF   500
0040E:  MOVFF  53D,502
00412:  MOVFF  53C,501
00416:  BRA    01AC
.................... 
....................     cli = (EmbeddedCli *) buf;
00418:  MOVFF  540,539
0041C:  MOVFF  53F,538
....................     buf += BYTES_TO_CLI_UINTS(sizeof(EmbeddedCli));
00420:  MOVLW  0C
00422:  ADDWF  53F,F
00424:  MOVLW  00
00426:  ADDWFC 540,F
.................... 
....................     cli->_impl = (EmbeddedCliImpl *) buf;
00428:  MOVLW  0A
0042A:  ADDWF  538,W
0042C:  MOVWF  4E9
0042E:  MOVLW  00
00430:  ADDWFC 539,W
00432:  MOVWF  4EA
00434:  MOVFF  540,4EC
00438:  MOVF   4ED,F
0043A:  MOVFF  53F,4EF
....................     buf += BYTES_TO_CLI_UINTS(sizeof(EmbeddedCliImpl));
0043E:  MOVLW  24
00440:  ADDWF  53F,F
00442:  MOVLW  00
00444:  ADDWFC 540,F
.................... 
....................     PREPARE_IMPL(cli);
00446:  MOVLW  0A
00448:  ADDWF  538,W
0044A:  MOVWF  4E9
0044C:  MOVLW  00
0044E:  ADDWFC 539,W
00450:  MOVWF  4EA
00452:  MOVFF  4EC,542
00456:  MOVF   4ED,F
00458:  MOVFF  4EF,541
....................     impl->rxBuffer.buf = (char *) buf;
0045C:  MOVLW  0A
0045E:  ADDWF  541,W
00460:  MOVWF  4E9
00462:  MOVLW  00
00464:  ADDWFC 542,W
00466:  MOVWF  4EA
00468:  MOVFF  540,4EC
0046C:  MOVF   4ED,F
0046E:  MOVFF  53F,4EF
....................     buf += BYTES_TO_CLI_UINTS(config->rxBufferSize * sizeof(char));
00472:  MOVLW  02
00474:  ADDWF  536,W
00476:  MOVWF  4E9
00478:  MOVLW  00
0047A:  ADDWFC 537,W
0047C:  MOVWF  4EA
0047E:  MOVFF  4EC,544
00482:  MOVF   4ED,F
00484:  MOVFF  4EF,543
00488:  MOVLW  02
0048A:  ADDWF  543,F
0048C:  MOVLW  00
0048E:  ADDWFC 544,F
00490:  MOVLW  01
00492:  SUBWF  543,F
00494:  MOVLW  00
00496:  SUBWFB 544,F
00498:  BCF    4D8.0
0049A:  RRCF   544,F
0049C:  RRCF   543,F
0049E:  BCF    4D8.0
004A0:  RLCF   543,W
004A2:  MOVWF  502
004A4:  RLCF   544,W
004A6:  MOVWF  503
004A8:  MOVF   502,W
004AA:  ADDWF  53F,F
004AC:  MOVF   503,W
004AE:  ADDWFC 540,F
.................... 
....................     impl->cmdBuffer = (char *) buf;
004B0:  MOVLW  12
004B2:  ADDWF  541,W
004B4:  MOVWF  4E9
004B6:  MOVLW  00
004B8:  ADDWFC 542,W
004BA:  MOVWF  4EA
004BC:  MOVFF  540,4EC
004C0:  MOVF   4ED,F
004C2:  MOVFF  53F,4EF
....................     buf += BYTES_TO_CLI_UINTS(config->cmdBufferSize * sizeof(char));
004C6:  MOVLW  04
004C8:  ADDWF  536,W
004CA:  MOVWF  4E9
004CC:  MOVLW  00
004CE:  ADDWFC 537,W
004D0:  MOVWF  4EA
004D2:  MOVFF  4EC,544
004D6:  MOVF   4ED,F
004D8:  MOVFF  4EF,543
004DC:  MOVLW  02
004DE:  ADDWF  543,F
004E0:  MOVLW  00
004E2:  ADDWFC 544,F
004E4:  MOVLW  01
004E6:  SUBWF  543,F
004E8:  MOVLW  00
004EA:  SUBWFB 544,F
004EC:  BCF    4D8.0
004EE:  RRCF   544,F
004F0:  RRCF   543,F
004F2:  BCF    4D8.0
004F4:  RLCF   543,W
004F6:  MOVWF  502
004F8:  RLCF   544,W
004FA:  MOVWF  503
004FC:  MOVF   502,W
004FE:  ADDWF  53F,F
00500:  MOVF   503,W
00502:  ADDWFC 540,F
.................... 
....................     impl->bindings = (CliCommandBinding *) buf;
00504:  MOVLW  18
00506:  ADDWF  541,W
00508:  MOVWF  4E9
0050A:  MOVLW  00
0050C:  ADDWFC 542,W
0050E:  MOVWF  4EA
00510:  MOVFF  540,4EC
00514:  MOVF   4ED,F
00516:  MOVFF  53F,4EF
....................     buf += BYTES_TO_CLI_UINTS(bindingCount * sizeof(CliCommandBinding));
0051A:  MOVFF  53B,5CD
0051E:  MOVFF  53A,5CC
00522:  MOVLB  5
00524:  CLRF   xCF
00526:  MOVLW  0B
00528:  MOVWF  xCE
0052A:  MOVLB  0
0052C:  RCALL  004A
0052E:  MOVFF  502,544
00532:  MOVFF  501,543
00536:  MOVLW  02
00538:  ADDWF  543,F
0053A:  MOVLW  00
0053C:  ADDWFC 544,F
0053E:  MOVLW  01
00540:  SUBWF  543,F
00542:  MOVLW  00
00544:  SUBWFB 544,F
00546:  BCF    4D8.0
00548:  RRCF   544,F
0054A:  RRCF   543,F
0054C:  BCF    4D8.0
0054E:  RLCF   543,W
00550:  MOVWF  502
00552:  RLCF   544,W
00554:  MOVWF  503
00556:  MOVF   502,W
00558:  ADDWF  53F,F
0055A:  MOVF   503,W
0055C:  ADDWFC 540,F
.................... 
....................     impl->bindingsFlags = (uint8_t *) buf;
0055E:  MOVLW  1A
00560:  ADDWF  541,W
00562:  MOVWF  4E9
00564:  MOVLW  00
00566:  ADDWFC 542,W
00568:  MOVWF  4EA
0056A:  MOVFF  540,4EC
0056E:  MOVF   4ED,F
00570:  MOVFF  53F,4EF
....................     buf += BYTES_TO_CLI_UINTS(bindingCount);
00574:  MOVLW  02
00576:  ADDWF  53A,W
00578:  MOVWF  543
0057A:  MOVLW  00
0057C:  ADDWFC 53B,W
0057E:  MOVWF  544
00580:  MOVLW  01
00582:  SUBWF  543,F
00584:  MOVLW  00
00586:  SUBWFB 544,F
00588:  BCF    4D8.0
0058A:  RRCF   544,F
0058C:  RRCF   543,F
0058E:  BCF    4D8.0
00590:  RLCF   543,W
00592:  MOVWF  502
00594:  RLCF   544,W
00596:  MOVWF  503
00598:  MOVF   502,W
0059A:  ADDWF  53F,F
0059C:  MOVF   503,W
0059E:  ADDWFC 540,F
.................... 
....................     impl->history.buf = (char *) buf;
005A0:  MOVLW  02
005A2:  ADDWF  541,W
005A4:  MOVWF  4E9
005A6:  MOVLW  00
005A8:  ADDWFC 542,W
005AA:  MOVWF  4EA
005AC:  MOVFF  540,4EC
005B0:  MOVF   4ED,F
005B2:  MOVFF  53F,4EF
....................     impl->history.bufferSize = config->historyBufferSize;
005B6:  MOVLW  04
005B8:  ADDWF  541,W
005BA:  MOVWF  501
005BC:  MOVLW  00
005BE:  ADDWFC 542,W
005C0:  MOVWF  503
005C2:  MOVWF  544
005C4:  MOVLW  06
005C6:  ADDWF  536,W
005C8:  MOVWF  4E9
005CA:  MOVLW  00
005CC:  ADDWFC 537,W
005CE:  MOVWF  4EA
005D0:  MOVFF  4EC,503
005D4:  MOVF   4ED,F
005D6:  MOVFF  4EF,545
005DA:  MOVFF  544,4EA
005DE:  MOVFF  501,4E9
005E2:  MOVFF  503,4EC
005E6:  MOVF   4ED,F
005E8:  MOVFF  545,4EF
.................... 
....................     if (allocated)
005EC:  BTFSS  53E.0
005EE:  BRA    0602
....................         SET_FLAG(impl->flags, CLI_FLAG_ALLOCATED);
005F0:  MOVLW  23
005F2:  ADDWF  541,W
005F4:  MOVWF  4E9
005F6:  MOVLW  00
005F8:  ADDWFC 542,W
005FA:  MOVWF  4EA
005FC:  MOVF   4EF,W
005FE:  IORLW  04
00600:  MOVWF  4EF
.................... 
....................     if (config->enableAutoComplete)
00602:  MOVLW  0E
00604:  ADDWF  536,W
00606:  MOVWF  4E9
00608:  MOVLW  00
0060A:  ADDWFC 537,W
0060C:  MOVWF  4EA
0060E:  BTFSS  4EF.0
00610:  BRA    0624
....................         SET_FLAG(impl->flags, CLI_FLAG_AUTOCOMPLETE_ENABLED);
00612:  MOVLW  23
00614:  ADDWF  541,W
00616:  MOVWF  4E9
00618:  MOVLW  00
0061A:  ADDWFC 542,W
0061C:  MOVWF  4EA
0061E:  MOVF   4EF,W
00620:  IORLW  20
00622:  MOVWF  4EF
.................... 
....................     impl->rxBuffer.size = config->rxBufferSize;
00624:  MOVLW  10
00626:  ADDWF  541,W
00628:  MOVWF  501
0062A:  MOVLW  00
0062C:  ADDWFC 542,W
0062E:  MOVWF  503
00630:  MOVWF  544
00632:  MOVLW  02
00634:  ADDWF  536,W
00636:  MOVWF  4E9
00638:  MOVLW  00
0063A:  ADDWFC 537,W
0063C:  MOVWF  4EA
0063E:  MOVFF  4EC,503
00642:  MOVF   4ED,F
00644:  MOVFF  4EF,545
00648:  MOVFF  544,4EA
0064C:  MOVFF  501,4E9
00650:  MOVFF  503,4EC
00654:  MOVF   4ED,F
00656:  MOVFF  545,4EF
....................     impl->rxBuffer.front = 0;
0065A:  MOVLW  0C
0065C:  ADDWF  541,W
0065E:  MOVWF  4E9
00660:  MOVLW  00
00662:  ADDWFC 542,W
00664:  MOVWF  4EA
00666:  CLRF   4EC
00668:  MOVF   4ED,F
0066A:  CLRF   4EF
....................     impl->rxBuffer.back = 0;
0066C:  MOVLW  0E
0066E:  ADDWF  541,W
00670:  MOVWF  4E9
00672:  MOVLW  00
00674:  ADDWFC 542,W
00676:  MOVWF  4EA
00678:  CLRF   4EC
0067A:  MOVF   4ED,F
0067C:  CLRF   4EF
....................     impl->cmdMaxSize = config->cmdBufferSize;
0067E:  MOVLW  16
00680:  ADDWF  541,W
00682:  MOVWF  501
00684:  MOVLW  00
00686:  ADDWFC 542,W
00688:  MOVWF  503
0068A:  MOVWF  544
0068C:  MOVLW  04
0068E:  ADDWF  536,W
00690:  MOVWF  4E9
00692:  MOVLW  00
00694:  ADDWFC 537,W
00696:  MOVWF  4EA
00698:  MOVFF  4EC,503
0069C:  MOVF   4ED,F
0069E:  MOVFF  4EF,545
006A2:  MOVFF  544,4EA
006A6:  MOVFF  501,4E9
006AA:  MOVFF  503,4EC
006AE:  MOVF   4ED,F
006B0:  MOVFF  545,4EF
....................     impl->bindingsCount = 0;
006B4:  MOVLW  1C
006B6:  ADDWF  541,W
006B8:  MOVWF  4E9
006BA:  MOVLW  00
006BC:  ADDWFC 542,W
006BE:  MOVWF  4EA
006C0:  CLRF   4EC
006C2:  MOVF   4ED,F
006C4:  CLRF   4EF
....................     impl->maxBindingsCount = (uint16_t) (config->maxBindingCount + cliInternalBindingCount);
006C6:  MOVLW  1E
006C8:  ADDWF  541,W
006CA:  MOVWF  501
006CC:  MOVLW  00
006CE:  ADDWFC 542,W
006D0:  MOVFF  501,543
006D4:  MOVWF  544
006D6:  MOVLW  08
006D8:  ADDWF  536,W
006DA:  MOVWF  4E9
006DC:  MOVLW  00
006DE:  ADDWFC 537,W
006E0:  MOVWF  4EA
006E2:  MOVFF  4EC,546
006E6:  MOVF   4ED,F
006E8:  MOVFF  4EF,545
006EC:  MOVF   519,W
006EE:  ADDWF  545,W
006F0:  MOVWF  501
006F2:  MOVF   51A,W
006F4:  ADDWFC 546,W
006F6:  MOVFF  544,4EA
006FA:  MOVFF  543,4E9
006FE:  MOVWF  4EC
00700:  MOVF   4ED,F
00702:  MOVFF  501,4EF
....................     impl->lastChar = '\0';
00706:  MOVLW  22
00708:  ADDWF  541,W
0070A:  MOVWF  4E9
0070C:  MOVLW  00
0070E:  ADDWFC 542,W
00710:  MOVWF  4EA
00712:  CLRF   4EF
....................     impl->invitation = config->invitation;
00714:  MOVFF  536,4E9
00718:  MOVFF  537,4EA
0071C:  MOVFF  4EC,503
00720:  MOVF   4ED,F
00722:  MOVFF  4EF,545
00726:  MOVFF  542,4EA
0072A:  MOVFF  541,4E9
0072E:  MOVFF  503,4EC
00732:  MOVF   4ED,F
00734:  MOVFF  545,4EF
.................... 
....................     initInternalBindings(cli);
00738:  MOVFF  539,544
0073C:  MOVFF  538,543
00740:  BRA    0294
.................... 
....................     return cli;
00742:  MOVFF  538,501
00746:  MOVFF  539,502
0074A:  GOTO   0762 (RETURN)
.................... }
.................... 
.................... EmbeddedCli *embeddedCliNewDefault(void) {
....................     return embeddedCliNew(embeddedCliDefaultConfig());
0074E:  RCALL  0018
00750:  MOVFF  502,535
00754:  MOVFF  501,534
00758:  MOVFF  502,537
0075C:  MOVFF  501,536
00760:  BRA    0360
00762:  MOVF   502,W
00764:  GOTO   2DA0 (RETURN)
.................... }
.................... 
.................... void embeddedCliReceiveChar(EmbeddedCli *cli, char c) {
....................     PREPARE_IMPL(cli);
.................... 
....................     if (!fifoBufPush(&impl->rxBuffer, c)) {
....................         SET_FLAG(impl->flags, CLI_FLAG_OVERFLOW);
....................     }
.................... }
.................... 
.................... void embeddedCliProcess(EmbeddedCli *cli) {
....................     if (cli->writeChar == NULL)
*
02BB0:  MOVF   534,W
02BB2:  MOVWF  4E9
02BB4:  MOVFF  535,4EA
02BB8:  MOVFF  4EF,539
02BBC:  MOVFF  4EC,53A
02BC0:  MOVFF  4EC,53B
02BC4:  MOVFF  4EC,53C
02BC8:  MOVF   539,F
02BCA:  BNZ   2BDA
02BCC:  MOVF   53A,F
02BCE:  BNZ   2BDA
02BD0:  MOVF   53B,F
02BD2:  BNZ   2BDA
02BD4:  MOVF   53C,F
02BD6:  BNZ   2BDA
....................         return;
02BD8:  BRA    2D86
.................... 
....................     PREPARE_IMPL(cli);
02BDA:  MOVLW  0A
02BDC:  ADDWF  534,W
02BDE:  MOVWF  4E9
02BE0:  MOVLW  00
02BE2:  ADDWFC 535,W
02BE4:  MOVWF  4EA
02BE6:  MOVFF  4EC,537
02BEA:  MOVF   4ED,F
02BEC:  MOVFF  4EF,536
.................... 
.................... 
....................     if (!IS_FLAG_SET(impl->flags, CLI_FLAG_INIT_COMPLETE)) {
02BF0:  MOVLW  23
02BF2:  ADDWF  536,W
02BF4:  MOVWF  4E9
02BF6:  MOVLW  00
02BF8:  ADDWFC 537,W
02BFA:  MOVWF  4EA
02BFC:  MOVF   4EF,W
02BFE:  ANDLW  02
02C00:  BNZ   2C32
....................         SET_FLAG(impl->flags, CLI_FLAG_INIT_COMPLETE);
02C02:  MOVLW  23
02C04:  ADDWF  536,W
02C06:  MOVWF  4E9
02C08:  MOVLW  00
02C0A:  ADDWFC 537,W
02C0C:  MOVWF  4EA
02C0E:  MOVF   4EF,W
02C10:  IORLW  02
02C12:  MOVWF  4EF
....................         writeToOutput(cli, impl->invitation);
02C14:  MOVFF  536,4E9
02C18:  MOVFF  537,4EA
02C1C:  MOVFF  4EC,615
02C20:  MOVF   4ED,F
02C22:  MOVFF  4EF,614
02C26:  MOVFF  535,613
02C2A:  MOVFF  534,612
02C2E:  CALL   07A2
....................     }
.................... 
....................     while (fifoBufAvailable(&impl->rxBuffer)) {
02C32:  MOVLW  0A
02C34:  ADDWF  536,W
02C36:  MOVWF  501
02C38:  MOVLW  00
02C3A:  ADDWFC 537,W
02C3C:  MOVWF  503
02C3E:  MOVFF  501,539
02C42:  MOVWF  53A
02C44:  MOVWF  53C
02C46:  MOVFF  501,53B
02C4A:  GOTO   0806
02C4E:  MOVF   501,W
02C50:  IORWF  502,W
02C52:  BZ    2D16
....................         char c = fifoBufPop(&impl->rxBuffer);
02C54:  MOVLW  0A
02C56:  ADDWF  536,W
02C58:  MOVWF  501
02C5A:  MOVLW  00
02C5C:  ADDWFC 537,W
02C5E:  MOVWF  503
02C60:  MOVFF  501,539
02C64:  MOVWF  53A
02C66:  MOVWF  53C
02C68:  MOVFF  501,53B
02C6C:  GOTO   0916
02C70:  MOVFF  501,538
.................... 
....................         if (IS_FLAG_SET(impl->flags, CLI_FLAG_ESCAPE_MODE)) {
02C74:  MOVLW  23
02C76:  ADDWF  536,W
02C78:  MOVWF  4E9
02C7A:  MOVLW  00
02C7C:  ADDWFC 537,W
02C7E:  MOVWF  4EA
02C80:  MOVF   4EF,W
02C82:  ANDLW  08
02C84:  BZ    2C98
....................             onEscapedInput(cli, c);
02C86:  MOVFF  535,53A
02C8A:  MOVFF  534,539
02C8E:  MOVFF  538,53B
02C92:  GOTO   1216
....................         } else if (impl->lastChar == 0x1B && c == '[') {
02C96:  BRA    2CF8
02C98:  MOVLW  22
02C9A:  ADDWF  536,W
02C9C:  MOVWF  4E9
02C9E:  MOVLW  00
02CA0:  ADDWFC 537,W
02CA2:  MOVWF  4EA
02CA4:  MOVF   4EF,W
02CA6:  SUBLW  1B
02CA8:  BNZ   2CC4
02CAA:  MOVF   538,W
02CAC:  SUBLW  5B
02CAE:  BNZ   2CC4
....................             //enter escape mode
....................             SET_FLAG(impl->flags, CLI_FLAG_ESCAPE_MODE);
02CB0:  MOVLW  23
02CB2:  ADDWF  536,W
02CB4:  MOVWF  4E9
02CB6:  MOVLW  00
02CB8:  ADDWFC 537,W
02CBA:  MOVWF  4EA
02CBC:  MOVF   4EF,W
02CBE:  IORLW  08
02CC0:  MOVWF  4EF
....................         } else if (isControlChar(c)) {
02CC2:  BRA    2CF8
02CC4:  MOVFF  538,539
02CC8:  GOTO   1274
02CCC:  MOVF   501,F
02CCE:  BZ    2CE0
....................             onControlInput(cli, c);
02CD0:  MOVFF  535,53A
02CD4:  MOVFF  534,539
02CD8:  MOVFF  538,53B
02CDC:  BRA    286A
....................         } else if (isDisplayableChar(c)) {
02CDE:  BRA    2CF8
02CE0:  MOVFF  538,539
02CE4:  BRA    2A8E
02CE6:  MOVF   501,F
02CE8:  BZ    2CF8
....................             onCharInput(cli, c);
02CEA:  MOVFF  535,53A
02CEE:  MOVFF  534,539
02CF2:  MOVFF  538,53B
02CF6:  BRA    2AA6
....................         }
.................... 
....................         printLiveAutocompletion(cli);
02CF8:  MOVFF  535,549
02CFC:  MOVFF  534,548
02D00:  CALL   0E3A
.................... 
....................         impl->lastChar = c;
02D04:  MOVLW  22
02D06:  ADDWF  536,W
02D08:  MOVWF  4E9
02D0A:  MOVLW  00
02D0C:  ADDWFC 537,W
02D0E:  MOVWF  4EA
02D10:  MOVFF  538,4EF
02D14:  BRA    2C32
....................     }
.................... 
....................     // discard unfinished command if overflow happened
....................     if (IS_FLAG_SET(impl->flags, CLI_FLAG_OVERFLOW)) {
02D16:  MOVLW  23
02D18:  ADDWF  536,W
02D1A:  MOVWF  4E9
02D1C:  MOVLW  00
02D1E:  ADDWFC 537,W
02D20:  MOVWF  4EA
02D22:  MOVF   4EF,W
02D24:  ANDLW  01
02D26:  BZ    2D86
....................         impl->cmdSize = 0;
02D28:  MOVLW  14
02D2A:  ADDWF  536,W
02D2C:  MOVWF  4E9
02D2E:  MOVLW  00
02D30:  ADDWFC 537,W
02D32:  MOVWF  4EA
02D34:  CLRF   4EC
02D36:  MOVF   4ED,F
02D38:  CLRF   4EF
....................         impl->cmdBuffer[impl->cmdSize] = '\0';
02D3A:  MOVLW  12
02D3C:  ADDWF  536,W
02D3E:  MOVWF  4E9
02D40:  MOVLW  00
02D42:  ADDWFC 537,W
02D44:  MOVWF  4EA
02D46:  MOVFF  4EC,53A
02D4A:  MOVF   4ED,F
02D4C:  MOVFF  4EF,539
02D50:  MOVLW  14
02D52:  ADDWF  536,W
02D54:  MOVWF  4E9
02D56:  MOVLW  00
02D58:  ADDWFC 537,W
02D5A:  MOVWF  4EA
02D5C:  MOVFF  4EC,53C
02D60:  MOVF   4ED,F
02D62:  MOVFF  4EF,53B
02D66:  MOVF   539,W
02D68:  ADDWF  53B,W
02D6A:  MOVWF  4E9
02D6C:  MOVF   53A,W
02D6E:  ADDWFC 53C,W
02D70:  MOVWF  4EA
02D72:  CLRF   4EF
....................         UNSET_U8FLAG(impl->flags, CLI_FLAG_OVERFLOW);
02D74:  MOVLW  23
02D76:  ADDWF  536,W
02D78:  MOVWF  4E9
02D7A:  MOVLW  00
02D7C:  ADDWFC 537,W
02D7E:  MOVWF  4EA
02D80:  MOVF   4EF,W
02D82:  ANDLW  FE
02D84:  MOVWF  4EF
....................     }
02D86:  GOTO   2E88 (RETURN)
.................... }
.................... 
.................... bool embeddedCliAddBinding(EmbeddedCli *cli, CliCommandBinding binding) {
*
001C8:  MOVLW  0A
001CA:  MOVLB  5
001CC:  ADDWF  x6C,W
001CE:  MOVWF  4E9
001D0:  MOVLW  00
001D2:  ADDWFC x6D,W
001D4:  MOVWF  4EA
001D6:  MOVFF  4EC,57A
001DA:  MOVF   4ED,F
001DC:  MOVFF  4EF,579
....................     PREPARE_IMPL(cli);
....................     if (impl->bindingsCount == impl->maxBindingsCount)
001E0:  MOVLW  1C
001E2:  ADDWF  x79,W
001E4:  MOVWF  4E9
001E6:  MOVLW  00
001E8:  ADDWFC x7A,W
001EA:  MOVWF  4EA
001EC:  MOVFF  4EC,57C
001F0:  MOVF   4ED,F
001F2:  MOVFF  4EF,57B
001F6:  MOVLW  1E
001F8:  ADDWF  x79,W
001FA:  MOVWF  4E9
001FC:  MOVLW  00
001FE:  ADDWFC x7A,W
00200:  MOVWF  4EA
00202:  MOVFF  4EC,503
00206:  MOVF   4ED,F
00208:  MOVF   4EF,W
0020A:  SUBWF  x7B,W
0020C:  BNZ   021A
0020E:  MOVF   503,W
00210:  SUBWF  x7C,W
00212:  BNZ   021A
....................         return false;
00214:  MOVLW  00
00216:  MOVWF  501
00218:  BRA    028E
.................... 
....................     impl->bindings[impl->bindingsCount] = binding;
0021A:  MOVLW  18
0021C:  ADDWF  x79,W
0021E:  MOVWF  4E9
00220:  MOVLW  00
00222:  ADDWFC x7A,W
00224:  MOVWF  4EA
00226:  MOVFF  4EC,57C
0022A:  MOVF   4ED,F
0022C:  MOVFF  4EF,57B
00230:  MOVLW  1C
00232:  ADDWF  x79,W
00234:  MOVWF  4E9
00236:  MOVLW  00
00238:  ADDWFC x7A,W
0023A:  MOVWF  4EA
0023C:  MOVFF  4EC,5CD
00240:  MOVF   4ED,F
00242:  MOVFF  4EF,5CC
00246:  CLRF   xCF
00248:  MOVLW  0B
0024A:  MOVWF  xCE
0024C:  MOVLB  0
0024E:  RCALL  004A
00250:  MOVFF  502,503
00254:  MOVF   501,W
00256:  MOVLB  5
00258:  ADDWF  x7B,W
0025A:  MOVWF  4E9
0025C:  MOVF   x7C,W
0025E:  ADDWFC 502,W
00260:  MOVWF  4EA
00262:  MOVLW  05
00264:  MOVWF  4E2
00266:  MOVLW  6E
00268:  MOVWF  4E1
0026A:  MOVLW  0B
0026C:  MOVWF  501
0026E:  MOVFF  4E6,4EE
00272:  DECFSZ 501,F
00274:  BRA    026E
.................... 
....................     ++impl->bindingsCount;
00276:  MOVLW  1C
00278:  ADDWF  x79,W
0027A:  MOVWF  4E9
0027C:  MOVLW  00
0027E:  ADDWFC x7A,W
00280:  MOVWF  4EA
00282:  MOVLW  01
00284:  ADDWF  4EE,F
00286:  BNC   028A
00288:  INCF   4EF,F
....................     return true;
0028A:  MOVLW  01
0028C:  MOVWF  501
0028E:  MOVLB  0
00290:  GOTO   035C (RETURN)
.................... }
.................... 
.................... void embeddedCliPrint(EmbeddedCli *cli, char *string) {
....................     if (cli->writeChar == NULL)
....................         return;
.................... 
....................     PREPARE_IMPL(cli);
.................... 
....................     // remove chars for autocompletion and live command
....................     if (!IS_FLAG_SET(impl->flags, CLI_FLAG_DIRECT_PRINT))
....................         clearCurrentLine(cli);
.................... 
....................     // print provided string
....................     writeToOutput(cli, string);
....................     writeToOutput(cli, lineBreak);
.................... 
....................     // print current command back to screen
....................     if (!IS_FLAG_SET(impl->flags, CLI_FLAG_DIRECT_PRINT)) {
....................         writeToOutput(cli, impl->invitation);
....................         writeToOutput(cli, impl->cmdBuffer);
....................         impl->inputLineLength = impl->cmdSize;
.................... 
....................         printLiveAutocompletion(cli);
....................     }
.................... }
.................... 
.................... void embeddedCliFree(EmbeddedCli *cli) {
....................     PREPARE_IMPL(cli);
....................     if (IS_FLAG_SET(impl->flags, CLI_FLAG_ALLOCATED)) {
....................         // allocation is done in single call to malloc, so need only single free
....................         //free(cli);
....................     }
.................... }
.................... 
.................... void embeddedCliTokenizeArgs(char *args) {
....................     if (args == NULL)
*
01B54:  MOVF   54F,F
01B56:  BNZ   1B5E
01B58:  MOVF   550,F
01B5A:  BNZ   1B5E
....................         return;
01B5C:  BRA    1C1A
.................... 
....................     // for now only space, but can add more later
....................     char *separators = " ";
01B5E:  MOVLW  20
01B60:  MOVWF  553
01B62:  CLRF   554
01B64:  MOVLW  05
01B66:  MOVWF  552
01B68:  MOVLW  53
01B6A:  MOVWF  551
.................... 
....................     // indicates that arg is quoted so separators are copied as is
....................     bool quotesEnabled = false;
....................     // indicates that previous char was a slash, so next char is copied as is
....................     bool escapeActivated = false;
....................     int insertPos = 0;
.................... 
....................     int i = 0;
....................     char currentChar;
01B6C:  BCF    555.0
01B6E:  BCF    555.1
01B70:  CLRF   556
01B72:  CLRF   557
....................     while ((currentChar = args[i]) != '\0') {
01B74:  MOVF   557,W
01B76:  ADDWF  54F,W
01B78:  MOVWF  4E9
01B7A:  MOVLW  00
01B7C:  ADDWFC 550,W
01B7E:  MOVWF  4EA
01B80:  MOVFF  4EF,558
01B84:  MOVF   558,F
01B86:  BZ    1BFC
....................         ++i;
01B88:  INCF   557,F
.................... 
....................         if (escapeActivated) {
01B8A:  BTFSS  555.1
01B8C:  BRA    1B92
....................             escapeActivated = false;
01B8E:  BCF    555.1
....................         } else if (currentChar == '\\') {
01B90:  BRA    1BCE
01B92:  MOVF   558,W
01B94:  SUBLW  5C
01B96:  BNZ   1B9E
....................             escapeActivated = true;
01B98:  BSF    555.1
....................             continue;
01B9A:  BRA    1B74
....................         } else if (currentChar == '"') {
01B9C:  BRA    1BCE
01B9E:  MOVF   558,W
01BA0:  SUBLW  22
01BA2:  BNZ   1BAA
....................             quotesEnabled = !quotesEnabled;
01BA4:  BTG    555.0
....................             currentChar = '\0';
01BA6:  CLRF   558
....................         } else if (!quotesEnabled && strchr(separators, currentChar) != NULL) {
01BA8:  BRA    1BCE
01BAA:  BTFSC  555.0
01BAC:  BRA    1BCE
01BAE:  MOVFF  552,55A
01BB2:  MOVFF  551,559
01BB6:  MOVFF  558,55B
01BBA:  BRA    1B16
01BBC:  MOVFF  502,55A
01BC0:  MOVFF  501,559
01BC4:  MOVF   559,F
01BC6:  BNZ   1BCC
01BC8:  MOVF   55A,F
01BCA:  BZ    1BCE
....................             currentChar = '\0';
01BCC:  CLRF   558
....................         }
.................... 
....................         // null chars are only copied once and not copied to the beginning
....................         if (currentChar != '\0' || (insertPos > 0 && args[insertPos - 1] != '\0')) {
01BCE:  MOVF   558,F
01BD0:  BNZ   1BE8
01BD2:  MOVF   556,F
01BD4:  BZ    1BFA
01BD6:  MOVLW  01
01BD8:  SUBWF  556,W
01BDA:  ADDWF  54F,W
01BDC:  MOVWF  4E9
01BDE:  MOVLW  00
01BE0:  ADDWFC 550,W
01BE2:  MOVWF  4EA
01BE4:  MOVF   4EF,F
01BE6:  BZ    1BFA
....................             args[insertPos] = currentChar;
01BE8:  MOVF   556,W
01BEA:  ADDWF  54F,W
01BEC:  MOVWF  4E9
01BEE:  MOVLW  00
01BF0:  ADDWFC 550,W
01BF2:  MOVWF  4EA
01BF4:  MOVFF  558,4EF
....................             ++insertPos;
01BF8:  INCF   556,F
....................         }
01BFA:  BRA    1B74
....................     }
.................... 
....................     // make args double null-terminated source buffer must be big enough to contain extra spaces
....................     args[insertPos] = '\0';
01BFC:  MOVF   556,W
01BFE:  ADDWF  54F,W
01C00:  MOVWF  4E9
01C02:  MOVLW  00
01C04:  ADDWFC 550,W
01C06:  MOVWF  4EA
01C08:  CLRF   4EF
....................     args[insertPos + 1] = '\0';
01C0A:  MOVLW  01
01C0C:  ADDWF  556,W
01C0E:  ADDWF  54F,W
01C10:  MOVWF  4E9
01C12:  MOVLW  00
01C14:  ADDWFC 550,W
01C16:  MOVWF  4EA
01C18:  CLRF   4EF
01C1A:  GOTO   26D8 (RETURN)
.................... }
.................... 
.................... char *embeddedCliGetToken(char *tokenizedStr, uint16_t pos) {
*
00B6A:  MOVFF  5CB,5D1
00B6E:  MOVFF  5CA,5D0
00B72:  MOVFF  5CD,5D3
00B76:  MOVFF  5CC,5D2
00B7A:  RCALL  0AD6
00B7C:  MOVFF  502,5CF
00B80:  MOVFF  501,5CE
....................     uint16_t i = getTokenPosition(tokenizedStr, pos);
.................... 
....................     if (i != CLI_TOKEN_NPOS)
00B84:  MOVLB  5
00B86:  INCFSZ xCE,W
00B88:  BRA    0B90
00B8A:  INCFSZ xCF,W
00B8C:  BRA    0B90
00B8E:  BRA    0BA2
....................         return &tokenizedStr[i];
00B90:  MOVF   xCA,W
00B92:  ADDWF  xCE,W
00B94:  MOVWF  501
00B96:  MOVF   xCB,W
00B98:  ADDWFC xCF,W
00B9A:  MOVWF  503
00B9C:  MOVWF  502
00B9E:  BRA    0BA8
00BA0:  BRA    0BA8
....................     else
....................         return NULL;
00BA2:  MOVLW  00
00BA4:  MOVWF  501
00BA6:  MOVWF  502
00BA8:  MOVLB  0
00BAA:  RETURN 0
.................... }
.................... 
.................... char *embeddedCliGetTokenVariable(char *tokenizedStr, uint16_t pos) {
*
015A6:  MOVFF  570,5D1
015AA:  MOVFF  56F,5D0
015AE:  MOVFF  572,5D3
015B2:  MOVFF  571,5D2
015B6:  CALL   0AD6
015BA:  MOVFF  502,574
015BE:  MOVFF  501,573
....................     uint16_t i = getTokenPosition(tokenizedStr, pos);
.................... 
....................     if (i != CLI_TOKEN_NPOS)
015C2:  MOVLB  5
015C4:  INCFSZ x73,W
015C6:  BRA    15CE
015C8:  INCFSZ x74,W
015CA:  BRA    15CE
015CC:  BRA    15E0
....................         return &tokenizedStr[i];
015CE:  MOVF   x6F,W
015D0:  ADDWF  x73,W
015D2:  MOVWF  501
015D4:  MOVF   x70,W
015D6:  ADDWFC x74,W
015D8:  MOVWF  503
015DA:  MOVWF  502
015DC:  BRA    15E6
015DE:  BRA    15E6
....................     else
....................         return NULL;
015E0:  MOVLW  00
015E2:  MOVWF  501
015E4:  MOVWF  502
015E6:  MOVLB  0
015E8:  GOTO   17BA (RETURN)
.................... }
.................... 
.................... uint16_t embeddedCliFindToken(char *tokenizedStr, char *token) {
....................     if (tokenizedStr == NULL || token == NULL)
....................         return 0;
.................... 
....................     uint16_t size = embeddedCliGetTokenCount(tokenizedStr);
....................     for (uint16_t i = 1; i <= size; ++i) {
....................         if (strcmp(embeddedCliGetToken(tokenizedStr, i), token) == 0)
....................             return i;
....................     }
.................... 
....................     return 0;
.................... }
.................... 
.................... uint16_t embeddedCliGetTokenCount(char *tokenizedStr) {
....................     if (tokenizedStr == NULL || tokenizedStr[0] == '\0')
*
01C1E:  MOVLB  5
01C20:  MOVF   xCA,F
01C22:  BNZ   1C28
01C24:  MOVF   xCB,F
01C26:  BZ    1C34
01C28:  MOVFF  5CA,4E9
01C2C:  MOVFF  5CB,4EA
01C30:  MOVF   4EF,F
01C32:  BNZ   1C3C
....................         return 0;
01C34:  MOVLW  00
01C36:  MOVWF  501
01C38:  MOVWF  502
01C3A:  BRA    1C7A
.................... 
....................     int i = 0;
....................     uint16_t tokenCount = 1;
01C3C:  CLRF   xCC
01C3E:  CLRF   xCE
01C40:  MOVLW  01
01C42:  MOVWF  xCD
....................     while (true) {
....................         if (tokenizedStr[i] == '\0') {
01C44:  MOVF   xCC,W
01C46:  ADDWF  xCA,W
01C48:  MOVWF  4E9
01C4A:  MOVLW  00
01C4C:  ADDWFC xCB,W
01C4E:  MOVWF  4EA
01C50:  MOVF   4EF,F
01C52:  BNZ   1C6E
....................             if (tokenizedStr[i + 1] == '\0')
01C54:  MOVLW  01
01C56:  ADDWF  xCC,W
01C58:  ADDWF  xCA,W
01C5A:  MOVWF  4E9
01C5C:  MOVLW  00
01C5E:  ADDWFC xCB,W
01C60:  MOVWF  4EA
01C62:  MOVF   4EF,F
01C64:  BNZ   1C68
....................                 break;
01C66:  BRA    1C72
....................             ++tokenCount;
01C68:  INCF   xCD,F
01C6A:  BTFSC  4D8.2
01C6C:  INCF   xCE,F
....................         }
....................         ++i;
01C6E:  INCF   xCC,F
01C70:  BRA    1C44
....................     }
.................... 
....................     return tokenCount;
01C72:  MOVFF  5CD,501
01C76:  MOVFF  5CE,502
01C7A:  MOVLB  0
01C7C:  GOTO   1EAE (RETURN)
.................... }
.................... 
.................... static void navigateHistory(EmbeddedCli *cli, bool navigateUp) {
*
00FEE:  MOVLW  0A
00FF0:  ADDWF  53F,W
00FF2:  MOVWF  4E9
00FF4:  MOVLW  00
00FF6:  ADDWFC 540,W
00FF8:  MOVWF  4EA
00FFA:  MOVFF  4EC,543
00FFE:  MOVF   4ED,F
01000:  MOVFF  4EF,542
....................     PREPARE_IMPL(cli);
....................     if (impl->history.itemsCount == 0 ||
....................         (navigateUp && impl->history.current == impl->history.itemsCount) ||
....................         (!navigateUp && impl->history.current == 0))
01004:  MOVLW  08
01006:  ADDWF  542,W
01008:  MOVWF  4E9
0100A:  MOVLW  00
0100C:  ADDWFC 543,W
0100E:  MOVWF  4EA
01010:  MOVFF  4EC,549
01014:  MOVF   4ED,F
01016:  MOVFF  4EF,548
0101A:  MOVF   548,F
0101C:  BNZ   1022
0101E:  MOVF   549,F
01020:  BZ    107C
01022:  MOVF   541,F
01024:  BZ    105A
01026:  MOVLW  06
01028:  ADDWF  542,W
0102A:  MOVWF  4E9
0102C:  MOVLW  00
0102E:  ADDWFC 543,W
01030:  MOVWF  4EA
01032:  MOVFF  4EC,549
01036:  MOVF   4ED,F
01038:  MOVFF  4EF,548
0103C:  MOVLW  08
0103E:  ADDWF  542,W
01040:  MOVWF  4E9
01042:  MOVLW  00
01044:  ADDWFC 543,W
01046:  MOVWF  4EA
01048:  MOVFF  4EC,503
0104C:  MOVF   4ED,F
0104E:  MOVF   4EF,W
01050:  SUBWF  548,W
01052:  BNZ   105A
01054:  MOVF   503,W
01056:  SUBWF  549,W
01058:  BZ    107C
0105A:  MOVF   541,F
0105C:  BNZ   107E
0105E:  MOVLW  06
01060:  ADDWF  542,W
01062:  MOVWF  4E9
01064:  MOVLW  00
01066:  ADDWFC 543,W
01068:  MOVWF  4EA
0106A:  MOVFF  4EC,549
0106E:  MOVF   4ED,F
01070:  MOVFF  4EF,548
01074:  MOVF   548,F
01076:  BNZ   107E
01078:  MOVF   549,F
0107A:  BNZ   107E
....................         return;
0107C:  BRA    1212
.................... 
....................     clearCurrentLine(cli);
0107E:  MOVFF  540,54C
01082:  MOVFF  53F,54B
01086:  RCALL  09F6
.................... 
....................     writeToOutput(cli, impl->invitation);
01088:  MOVFF  542,4E9
0108C:  MOVFF  543,4EA
01090:  MOVFF  4EC,615
01094:  MOVF   4ED,F
01096:  MOVFF  4EF,614
0109A:  MOVFF  540,613
0109E:  MOVFF  53F,612
010A2:  CALL   07A2
.................... 
....................     if (navigateUp)
010A6:  MOVF   541,F
010A8:  BZ    10C0
....................         ++impl->history.current;
010AA:  MOVLW  06
010AC:  ADDWF  542,W
010AE:  MOVWF  4E9
010B0:  MOVLW  00
010B2:  ADDWFC 543,W
010B4:  MOVWF  4EA
010B6:  MOVLW  01
010B8:  ADDWF  4EE,F
010BA:  BNC   10BE
010BC:  INCF   4EF,F
010BE:  BRA    10D6
....................     else
....................         --impl->history.current;
010C0:  MOVLW  06
010C2:  ADDWF  542,W
010C4:  MOVWF  4E9
010C6:  MOVLW  00
010C8:  ADDWFC 543,W
010CA:  MOVWF  4EA
010CC:  MOVLW  FF
010CE:  ADDWF  4EF,F
010D0:  BC    10D6
010D2:  MOVF   4EE,F
010D4:  DECF   4ED,F
.................... 
....................     char *item = historyGet(&impl->history, impl->history.current);
010D6:  MOVLW  02
010D8:  ADDWF  542,W
010DA:  MOVWF  501
010DC:  MOVLW  00
010DE:  ADDWFC 543,W
010E0:  MOVWF  503
010E2:  MOVFF  501,548
010E6:  MOVWF  549
010E8:  MOVLW  06
010EA:  ADDWF  542,W
010EC:  MOVWF  4E9
010EE:  MOVLW  00
010F0:  ADDWFC 543,W
010F2:  MOVWF  4EA
010F4:  MOVFF  4EC,566
010F8:  MOVF   4ED,F
010FA:  MOVFF  4EF,565
010FE:  MOVFF  503,564
01102:  MOVFF  501,563
01106:  RCALL  0BAC
01108:  MOVFF  502,545
0110C:  MOVFF  501,544
....................     // simple way to handle empty command the same way as others
....................     if (item == NULL)
01110:  MOVF   544,F
01112:  BNZ   111C
01114:  MOVF   545,F
01116:  BNZ   111C
....................         item = "";
01118:  CLRF   544
0111A:  CLRF   545
....................     uint16_t len = (uint16_t) strlen(item);
0111C:  MOVFF  545,61B
01120:  MOVFF  544,61A
01124:  CALL   0768
01128:  MOVFF  502,547
0112C:  MOVFF  501,546
....................     memcpy(impl->cmdBuffer, item, len);
01130:  MOVLW  12
01132:  ADDWF  542,W
01134:  MOVWF  4E9
01136:  MOVLW  00
01138:  ADDWFC 543,W
0113A:  MOVWF  4EA
0113C:  MOVFF  4EC,549
01140:  MOVF   4ED,F
01142:  MOVFF  4EF,548
01146:  MOVFF  549,4EA
0114A:  MOVFF  548,4E9
0114E:  MOVFF  545,4E2
01152:  MOVFF  544,4E1
01156:  MOVFF  547,502
0115A:  MOVFF  546,501
0115E:  MOVF   501,F
01160:  BZ    1166
01162:  INCF   502,F
01164:  BRA    116A
01166:  MOVF   502,F
01168:  BZ    1176
0116A:  MOVFF  4E6,4EE
0116E:  DECFSZ 501,F
01170:  BRA    116A
01172:  DECFSZ 502,F
01174:  BRA    116A
....................     impl->cmdBuffer[len] = '\0';
01176:  MOVLW  12
01178:  ADDWF  542,W
0117A:  MOVWF  4E9
0117C:  MOVLW  00
0117E:  ADDWFC 543,W
01180:  MOVWF  4EA
01182:  MOVFF  4EC,549
01186:  MOVF   4ED,F
01188:  MOVFF  4EF,548
0118C:  MOVF   548,W
0118E:  ADDWF  546,W
01190:  MOVWF  4E9
01192:  MOVF   549,W
01194:  ADDWFC 547,W
01196:  MOVWF  4EA
01198:  CLRF   4EF
....................     impl->cmdSize = len;
0119A:  MOVLW  14
0119C:  ADDWF  542,W
0119E:  MOVWF  4E9
011A0:  MOVLW  00
011A2:  ADDWFC 543,W
011A4:  MOVWF  4EA
011A6:  MOVFF  547,4EC
011AA:  MOVF   4ED,F
011AC:  MOVFF  546,4EF
.................... 
....................     writeToOutput(cli, impl->cmdBuffer);
011B0:  MOVLW  12
011B2:  ADDWF  542,W
011B4:  MOVWF  4E9
011B6:  MOVLW  00
011B8:  ADDWFC 543,W
011BA:  MOVWF  4EA
011BC:  MOVFF  4EC,615
011C0:  MOVF   4ED,F
011C2:  MOVFF  4EF,614
011C6:  MOVFF  540,613
011CA:  MOVFF  53F,612
011CE:  CALL   07A2
....................     impl->inputLineLength = impl->cmdSize;
011D2:  MOVLW  20
011D4:  ADDWF  542,W
011D6:  MOVWF  501
011D8:  MOVLW  00
011DA:  ADDWFC 543,W
011DC:  MOVWF  503
011DE:  MOVWF  549
011E0:  MOVLW  14
011E2:  ADDWF  542,W
011E4:  MOVWF  4E9
011E6:  MOVLW  00
011E8:  ADDWFC 543,W
011EA:  MOVWF  4EA
011EC:  MOVFF  4EC,503
011F0:  MOVF   4ED,F
011F2:  MOVFF  4EF,54A
011F6:  MOVFF  549,4EA
011FA:  MOVFF  501,4E9
011FE:  MOVFF  503,4EC
01202:  MOVF   4ED,F
01204:  MOVFF  54A,4EF
.................... 
....................     printLiveAutocompletion(cli);
01208:  MOVFF  540,549
0120C:  MOVFF  53F,548
01210:  RCALL  0E3A
01212:  GOTO   1270 (RETURN)
.................... }
.................... 
.................... static void onEscapedInput(EmbeddedCli *cli, char c) {
01216:  MOVLW  0A
01218:  ADDWF  539,W
0121A:  MOVWF  4E9
0121C:  MOVLW  00
0121E:  ADDWFC 53A,W
01220:  MOVWF  4EA
01222:  MOVFF  4EC,53D
01226:  MOVF   4ED,F
01228:  MOVFF  4EF,53C
....................     PREPARE_IMPL(cli);
.................... 
....................     if (c >= 64 && c <= 126) {
0122C:  MOVF   53B,W
0122E:  SUBLW  3F
01230:  BC    1270
01232:  MOVF   53B,W
01234:  SUBLW  7E
01236:  BNC   1270
....................         // handle escape sequence
....................         UNSET_U8FLAG(impl->flags, CLI_FLAG_ESCAPE_MODE);
01238:  MOVLW  23
0123A:  ADDWF  53C,W
0123C:  MOVWF  4E9
0123E:  MOVLW  00
01240:  ADDWFC 53D,W
01242:  MOVWF  4EA
01244:  MOVF   4EF,W
01246:  ANDLW  F7
01248:  MOVWF  4EF
.................... 
....................         if (c == 'A' || c == 'B') {
0124A:  MOVF   53B,W
0124C:  SUBLW  41
0124E:  BZ    1256
01250:  MOVF   53B,W
01252:  SUBLW  42
01254:  BNZ   1270
....................             // treat \e[..A as cursor up and \e[..B as cursor down
....................             // there might be extra chars between [ and A/B, just ignore them
....................             navigateHistory(cli, c == 'A');
01256:  MOVF   53B,W
01258:  SUBLW  41
0125A:  BZ    1260
0125C:  MOVLW  00
0125E:  BRA    1262
01260:  MOVLW  01
01262:  MOVWF  53E
01264:  MOVFF  53A,540
01268:  MOVFF  539,53F
0126C:  MOVWF  541
0126E:  BRA    0FEE
....................         }
....................     }
01270:  GOTO   2C96 (RETURN)
.................... }
.................... 
.................... static void onCharInput(EmbeddedCli *cli, char c) {
*
02AA6:  MOVLW  0A
02AA8:  ADDWF  539,W
02AAA:  MOVWF  4E9
02AAC:  MOVLW  00
02AAE:  ADDWFC 53A,W
02AB0:  MOVWF  4EA
02AB2:  MOVFF  4EC,53D
02AB6:  MOVF   4ED,F
02AB8:  MOVFF  4EF,53C
....................     PREPARE_IMPL(cli);
.................... 
....................     // have to reserve two extra chars for command ending (used in tokenization)
....................     if (impl->cmdSize + 2 >= impl->cmdMaxSize)
02ABC:  MOVLW  14
02ABE:  ADDWF  53C,W
02AC0:  MOVWF  4E9
02AC2:  MOVLW  00
02AC4:  ADDWFC 53D,W
02AC6:  MOVWF  4EA
02AC8:  MOVFF  4EC,53F
02ACC:  MOVF   4ED,F
02ACE:  MOVFF  4EF,53E
02AD2:  MOVLW  02
02AD4:  ADDWF  53E,F
02AD6:  MOVLW  00
02AD8:  ADDWFC 53F,F
02ADA:  MOVLW  16
02ADC:  ADDWF  53C,W
02ADE:  MOVWF  4E9
02AE0:  MOVLW  00
02AE2:  ADDWFC 53D,W
02AE4:  MOVWF  4EA
02AE6:  MOVFF  4EC,503
02AEA:  MOVF   4ED,F
02AEC:  MOVFF  4EF,501
02AF0:  MOVF   503,W
02AF2:  SUBWF  53F,W
02AF4:  BNC   2B00
02AF6:  BNZ   2AFE
02AF8:  MOVF   501,W
02AFA:  SUBWF  53E,W
02AFC:  BNC   2B00
....................         return;
02AFE:  BRA    2BAC
.................... 
....................     impl->cmdBuffer[impl->cmdSize] = c;
02B00:  MOVLW  12
02B02:  ADDWF  53C,W
02B04:  MOVWF  4E9
02B06:  MOVLW  00
02B08:  ADDWFC 53D,W
02B0A:  MOVWF  4EA
02B0C:  MOVFF  4EC,53F
02B10:  MOVF   4ED,F
02B12:  MOVFF  4EF,53E
02B16:  MOVLW  14
02B18:  ADDWF  53C,W
02B1A:  MOVWF  4E9
02B1C:  MOVLW  00
02B1E:  ADDWFC 53D,W
02B20:  MOVWF  4EA
02B22:  MOVFF  4EC,541
02B26:  MOVF   4ED,F
02B28:  MOVFF  4EF,540
02B2C:  MOVF   53E,W
02B2E:  ADDWF  540,W
02B30:  MOVWF  4E9
02B32:  MOVF   53F,W
02B34:  ADDWFC 541,W
02B36:  MOVWF  4EA
02B38:  MOVFF  53B,4EF
....................     ++impl->cmdSize;
02B3C:  MOVLW  14
02B3E:  ADDWF  53C,W
02B40:  MOVWF  4E9
02B42:  MOVLW  00
02B44:  ADDWFC 53D,W
02B46:  MOVWF  4EA
02B48:  MOVLW  01
02B4A:  ADDWF  4EE,F
02B4C:  BNC   2B50
02B4E:  INCF   4EF,F
....................     impl->cmdBuffer[impl->cmdSize] = '\0';
02B50:  MOVLW  12
02B52:  ADDWF  53C,W
02B54:  MOVWF  4E9
02B56:  MOVLW  00
02B58:  ADDWFC 53D,W
02B5A:  MOVWF  4EA
02B5C:  MOVFF  4EC,53F
02B60:  MOVF   4ED,F
02B62:  MOVFF  4EF,53E
02B66:  MOVLW  14
02B68:  ADDWF  53C,W
02B6A:  MOVWF  4E9
02B6C:  MOVLW  00
02B6E:  ADDWFC 53D,W
02B70:  MOVWF  4EA
02B72:  MOVFF  4EC,541
02B76:  MOVF   4ED,F
02B78:  MOVFF  4EF,540
02B7C:  MOVF   53E,W
02B7E:  ADDWF  540,W
02B80:  MOVWF  4E9
02B82:  MOVF   53F,W
02B84:  ADDWFC 541,W
02B86:  MOVWF  4EA
02B88:  CLRF   4EF
.................... 
....................     cli->writeChar(cli, c);
02B8A:  MOVFF  539,500
02B8E:  MOVF   53A,W
02B90:  MOVWF  501
02B92:  CLRF   502
02B94:  MOVWF  53E
02B96:  CLRF   53F
02B98:  CLRF   4EA
02B9A:  MOVWF  4E9
02B9C:  MOVFF  53A,526
02BA0:  MOVFF  539,525
02BA4:  MOVFF  53B,527
02BA8:  CALL   0004
02BAC:  GOTO   2CF8 (RETURN)
.................... }
.................... 
.................... static void onControlInput(EmbeddedCli *cli, char c) {
*
0286A:  MOVLW  0A
0286C:  ADDWF  539,W
0286E:  MOVWF  4E9
02870:  MOVLW  00
02872:  ADDWFC 53A,W
02874:  MOVWF  4EA
02876:  MOVFF  4EC,53D
0287A:  MOVF   4ED,F
0287C:  MOVFF  4EF,53C
....................     PREPARE_IMPL(cli);
.................... 
....................     // process \r\n and \n\r as single \r\n command
....................     if ((impl->lastChar == '\r' && c == '\n') ||
....................         (impl->lastChar == '\n' && c == '\r'))
02880:  MOVLW  22
02882:  ADDWF  53C,W
02884:  MOVWF  4E9
02886:  MOVLW  00
02888:  ADDWFC 53D,W
0288A:  MOVWF  4EA
0288C:  MOVF   4EF,W
0288E:  SUBLW  0D
02890:  BNZ   2898
02892:  MOVF   53B,W
02894:  SUBLW  0A
02896:  BZ    28B0
02898:  MOVLW  22
0289A:  ADDWF  53C,W
0289C:  MOVWF  4E9
0289E:  MOVLW  00
028A0:  ADDWFC 53D,W
028A2:  MOVWF  4EA
028A4:  MOVF   4EF,W
028A6:  SUBLW  0A
028A8:  BNZ   28B2
028AA:  MOVF   53B,W
028AC:  SUBLW  0D
028AE:  BNZ   28B2
....................         return;
028B0:  BRA    2A8A
.................... 
....................     if (c == '\r' || c == '\n') {
028B2:  MOVF   53B,W
028B4:  SUBLW  0D
028B6:  BZ    28BE
028B8:  MOVF   53B,W
028BA:  SUBLW  0A
028BC:  BNZ   2996
....................         // try to autocomplete command and then process it
....................         onAutocompleteRequest(cli);
028BE:  MOVFF  53A,53F
028C2:  MOVFF  539,53E
028C6:  CALL   129E
.................... 
....................         writeToOutput(cli, lineBreak);
028CA:  MOVFF  53A,613
028CE:  MOVFF  539,612
028D2:  MOVFF  51C,615
028D6:  MOVFF  51B,614
028DA:  CALL   07A2
.................... 
....................         if (impl->cmdSize > 0)
028DE:  MOVLW  14
028E0:  ADDWF  53C,W
028E2:  MOVWF  4E9
028E4:  MOVLW  00
028E6:  ADDWFC 53D,W
028E8:  MOVWF  4EA
028EA:  MOVFF  4EC,53F
028EE:  MOVF   4ED,F
028F0:  MOVFF  4EF,53E
028F4:  MOVF   53E,F
028F6:  BNZ   28FC
028F8:  MOVF   53F,F
028FA:  BZ    2906
....................             parseCommand(cli);
028FC:  MOVFF  53A,53F
02900:  MOVFF  539,53E
02904:  BRA    23B2
....................         impl->cmdSize = 0;
02906:  MOVLW  14
02908:  ADDWF  53C,W
0290A:  MOVWF  4E9
0290C:  MOVLW  00
0290E:  ADDWFC 53D,W
02910:  MOVWF  4EA
02912:  CLRF   4EC
02914:  MOVF   4ED,F
02916:  CLRF   4EF
....................         impl->cmdBuffer[impl->cmdSize] = '\0';
02918:  MOVLW  12
0291A:  ADDWF  53C,W
0291C:  MOVWF  4E9
0291E:  MOVLW  00
02920:  ADDWFC 53D,W
02922:  MOVWF  4EA
02924:  MOVFF  4EC,53F
02928:  MOVF   4ED,F
0292A:  MOVFF  4EF,53E
0292E:  MOVLW  14
02930:  ADDWF  53C,W
02932:  MOVWF  4E9
02934:  MOVLW  00
02936:  ADDWFC 53D,W
02938:  MOVWF  4EA
0293A:  MOVFF  4EC,541
0293E:  MOVF   4ED,F
02940:  MOVFF  4EF,540
02944:  MOVF   53E,W
02946:  ADDWF  540,W
02948:  MOVWF  4E9
0294A:  MOVF   53F,W
0294C:  ADDWFC 541,W
0294E:  MOVWF  4EA
02950:  CLRF   4EF
....................         impl->inputLineLength = 0;
02952:  MOVLW  20
02954:  ADDWF  53C,W
02956:  MOVWF  4E9
02958:  MOVLW  00
0295A:  ADDWFC 53D,W
0295C:  MOVWF  4EA
0295E:  CLRF   4EC
02960:  MOVF   4ED,F
02962:  CLRF   4EF
....................         impl->history.current = 0;
02964:  MOVLW  06
02966:  ADDWF  53C,W
02968:  MOVWF  4E9
0296A:  MOVLW  00
0296C:  ADDWFC 53D,W
0296E:  MOVWF  4EA
02970:  CLRF   4EC
02972:  MOVF   4ED,F
02974:  CLRF   4EF
.................... 
....................         writeToOutput(cli, impl->invitation);
02976:  MOVFF  53C,4E9
0297A:  MOVFF  53D,4EA
0297E:  MOVFF  4EC,615
02982:  MOVF   4ED,F
02984:  MOVFF  4EF,614
02988:  MOVFF  53A,613
0298C:  MOVFF  539,612
02990:  CALL   07A2
....................     } else if ((c == '\b' || c == 0x7F) && impl->cmdSize > 0) {
02994:  BRA    2A8A
02996:  MOVF   53B,W
02998:  SUBLW  08
0299A:  BZ    29A2
0299C:  MOVF   53B,W
0299E:  SUBLW  7F
029A0:  BNZ   2A78
029A2:  MOVLW  14
029A4:  ADDWF  53C,W
029A6:  MOVWF  4E9
029A8:  MOVLW  00
029AA:  ADDWFC 53D,W
029AC:  MOVWF  4EA
029AE:  MOVFF  4EC,53F
029B2:  MOVF   4ED,F
029B4:  MOVFF  4EF,53E
029B8:  MOVF   53E,F
029BA:  BNZ   29C0
029BC:  MOVF   53F,F
029BE:  BZ    2A78
....................         // remove char from screen
....................         cli->writeChar(cli, '\b');
029C0:  MOVFF  539,500
029C4:  MOVF   53A,W
029C6:  MOVWF  501
029C8:  CLRF   502
029CA:  MOVWF  53E
029CC:  CLRF   53F
029CE:  CLRF   4EA
029D0:  MOVWF  4E9
029D2:  MOVFF  53A,526
029D6:  MOVFF  539,525
029DA:  MOVLW  08
029DC:  MOVWF  527
029DE:  CALL   0004
....................         cli->writeChar(cli, ' ');
029E2:  MOVFF  539,500
029E6:  MOVF   53A,W
029E8:  MOVWF  501
029EA:  CLRF   502
029EC:  MOVWF  53E
029EE:  CLRF   53F
029F0:  CLRF   4EA
029F2:  MOVWF  4E9
029F4:  MOVFF  53A,526
029F8:  MOVFF  539,525
029FC:  MOVLW  20
029FE:  MOVWF  527
02A00:  CALL   0004
....................         cli->writeChar(cli, '\b');
02A04:  MOVFF  539,500
02A08:  MOVF   53A,W
02A0A:  MOVWF  501
02A0C:  CLRF   502
02A0E:  MOVWF  53E
02A10:  CLRF   53F
02A12:  CLRF   4EA
02A14:  MOVWF  4E9
02A16:  MOVFF  53A,526
02A1A:  MOVFF  539,525
02A1E:  MOVLW  08
02A20:  MOVWF  527
02A22:  CALL   0004
....................         // and from buffer
....................         --impl->cmdSize;
02A26:  MOVLW  14
02A28:  ADDWF  53C,W
02A2A:  MOVWF  4E9
02A2C:  MOVLW  00
02A2E:  ADDWFC 53D,W
02A30:  MOVWF  4EA
02A32:  MOVLW  FF
02A34:  ADDWF  4EF,F
02A36:  BC    2A3C
02A38:  MOVF   4EE,F
02A3A:  DECF   4ED,F
....................         impl->cmdBuffer[impl->cmdSize] = '\0';
02A3C:  MOVLW  12
02A3E:  ADDWF  53C,W
02A40:  MOVWF  4E9
02A42:  MOVLW  00
02A44:  ADDWFC 53D,W
02A46:  MOVWF  4EA
02A48:  MOVFF  4EC,53F
02A4C:  MOVF   4ED,F
02A4E:  MOVFF  4EF,53E
02A52:  MOVLW  14
02A54:  ADDWF  53C,W
02A56:  MOVWF  4E9
02A58:  MOVLW  00
02A5A:  ADDWFC 53D,W
02A5C:  MOVWF  4EA
02A5E:  MOVFF  4EC,541
02A62:  MOVF   4ED,F
02A64:  MOVFF  4EF,540
02A68:  MOVF   53E,W
02A6A:  ADDWF  540,W
02A6C:  MOVWF  4E9
02A6E:  MOVF   53F,W
02A70:  ADDWFC 541,W
02A72:  MOVWF  4EA
02A74:  CLRF   4EF
....................     } else if (c == '\t') {
02A76:  BRA    2A8A
02A78:  MOVF   53B,W
02A7A:  SUBLW  09
02A7C:  BNZ   2A8A
....................         onAutocompleteRequest(cli);
02A7E:  MOVFF  53A,53F
02A82:  MOVFF  539,53E
02A86:  CALL   129E
....................     }
02A8A:  GOTO   2CDE (RETURN)
.................... 
.................... }
.................... 
.................... static void parseCommand(EmbeddedCli *cli) {
*
023B2:  MOVLW  0A
023B4:  ADDWF  53E,W
023B6:  MOVWF  4E9
023B8:  MOVLW  00
023BA:  ADDWFC 53F,W
023BC:  MOVWF  4EA
023BE:  MOVFF  4EC,541
023C2:  MOVF   4ED,F
023C4:  MOVFF  4EF,540
023C8:  BSF    542.0
....................     PREPARE_IMPL(cli);
.................... 
....................     bool isEmpty = true;
.................... 
....................     for (int i = 0; i < impl->cmdSize; ++i) {
023CA:  CLRF   543
023CC:  MOVLW  14
023CE:  ADDWF  540,W
023D0:  MOVWF  4E9
023D2:  MOVLW  00
023D4:  ADDWFC 541,W
023D6:  MOVWF  4EA
023D8:  MOVFF  4EC,503
023DC:  MOVF   4ED,F
023DE:  MOVFF  4EF,501
023E2:  MOVF   503,F
023E4:  BNZ   23EC
023E6:  MOVF   501,W
023E8:  SUBWF  543,W
023EA:  BC    241C
....................         if (impl->cmdBuffer[i] != ' ') {
023EC:  MOVLW  12
023EE:  ADDWF  540,W
023F0:  MOVWF  4E9
023F2:  MOVLW  00
023F4:  ADDWFC 541,W
023F6:  MOVWF  4EA
023F8:  MOVFF  4EC,550
023FC:  MOVF   4ED,F
023FE:  MOVFF  4EF,54F
02402:  MOVF   543,W
02404:  ADDWF  54F,W
02406:  MOVWF  4E9
02408:  MOVLW  00
0240A:  ADDWFC 550,W
0240C:  MOVWF  4EA
0240E:  MOVF   4EF,W
02410:  SUBLW  20
02412:  BZ    2418
....................             isEmpty = false;
02414:  BCF    542.0
....................             break;
02416:  BRA    241C
....................         }
02418:  INCF   543,F
0241A:  BRA    23CC
....................     }
....................     // do not process empty commands
....................     if (isEmpty)
0241C:  BTFSS  542.0
0241E:  BRA    2422
....................         return;
02420:  BRA    2866
....................     // push command to history before buffer is modified
....................     historyPut(&impl->history, impl->cmdBuffer);
02422:  MOVLW  02
02424:  ADDWF  540,W
02426:  MOVWF  501
02428:  MOVLW  00
0242A:  ADDWFC 541,W
0242C:  MOVWF  503
0242E:  MOVFF  501,54F
02432:  MOVWF  550
02434:  MOVLW  12
02436:  ADDWF  540,W
02438:  MOVWF  4E9
0243A:  MOVLW  00
0243C:  ADDWFC 541,W
0243E:  MOVWF  4EA
02440:  MOVFF  4EC,556
02444:  MOVF   4ED,F
02446:  MOVFF  4EF,555
0244A:  MOVFF  503,554
0244E:  MOVFF  501,553
02452:  GOTO   18E8
.................... 
....................     char *cmdName = NULL;
....................     char *cmdArgs = NULL;
....................     bool nameFinished = false;
02456:  CLRF   545
02458:  CLRF   544
0245A:  CLRF   547
0245C:  CLRF   546
0245E:  BCF    542.1
.................... 
....................     // find command name and command args inside command buffer
....................     for (int i = 0; i < impl->cmdSize; ++i) {
02460:  CLRF   548
02462:  MOVLW  14
02464:  ADDWF  540,W
02466:  MOVWF  4E9
02468:  MOVLW  00
0246A:  ADDWFC 541,W
0246C:  MOVWF  4EA
0246E:  MOVFF  4EC,503
02472:  MOVF   4ED,F
02474:  MOVFF  4EF,501
02478:  MOVF   503,F
0247A:  BNZ   2482
0247C:  MOVF   501,W
0247E:  SUBWF  548,W
02480:  BC    254C
....................         char c = impl->cmdBuffer[i];
02482:  MOVLW  12
02484:  ADDWF  540,W
02486:  MOVWF  4E9
02488:  MOVLW  00
0248A:  ADDWFC 541,W
0248C:  MOVWF  4EA
0248E:  MOVFF  4EC,550
02492:  MOVF   4ED,F
02494:  MOVFF  4EF,54F
02498:  MOVF   548,W
0249A:  ADDWF  54F,W
0249C:  MOVWF  4E9
0249E:  MOVLW  00
024A0:  ADDWFC 550,W
024A2:  MOVWF  4EA
024A4:  MOVFF  4EF,549
.................... 
....................         if (c == ' ') {
024A8:  MOVF   549,W
024AA:  SUBLW  20
024AC:  BNZ   24E6
....................             // all spaces between name and args are filled with zeros
....................             // so name is a correct null-terminated string
....................             if (cmdArgs == NULL)
024AE:  MOVF   546,F
024B0:  BNZ   24DA
024B2:  MOVF   547,F
024B4:  BNZ   24DA
....................                 impl->cmdBuffer[i] = '\0';
024B6:  MOVLW  12
024B8:  ADDWF  540,W
024BA:  MOVWF  4E9
024BC:  MOVLW  00
024BE:  ADDWFC 541,W
024C0:  MOVWF  4EA
024C2:  MOVFF  4EC,550
024C6:  MOVF   4ED,F
024C8:  MOVFF  4EF,54F
024CC:  MOVF   548,W
024CE:  ADDWF  54F,W
024D0:  MOVWF  4E9
024D2:  MOVLW  00
024D4:  ADDWFC 550,W
024D6:  MOVWF  4EA
024D8:  CLRF   4EF
....................             if (cmdName != NULL)
024DA:  MOVF   544,F
024DC:  BNZ   24E2
024DE:  MOVF   545,F
024E0:  BZ    24E4
....................                 nameFinished = true;
024E2:  BSF    542.1
.................... 
....................         } else if (cmdName == NULL) {
024E4:  BRA    2548
024E6:  MOVF   544,F
024E8:  BNZ   2516
024EA:  MOVF   545,F
024EC:  BNZ   2516
....................             cmdName = &impl->cmdBuffer[i];
024EE:  MOVLW  12
024F0:  ADDWF  540,W
024F2:  MOVWF  4E9
024F4:  MOVLW  00
024F6:  ADDWFC 541,W
024F8:  MOVWF  4EA
024FA:  MOVFF  4EC,550
024FE:  MOVF   4ED,F
02500:  MOVFF  4EF,54F
02504:  MOVF   548,W
02506:  ADDWF  54F,W
02508:  MOVWF  501
0250A:  MOVLW  00
0250C:  ADDWFC 550,W
0250E:  MOVFF  501,544
02512:  MOVWF  545
....................         } else if (cmdArgs == NULL && nameFinished) {
02514:  BRA    2548
02516:  MOVF   546,F
02518:  BNZ   2548
0251A:  MOVF   547,F
0251C:  BNZ   2548
0251E:  BTFSS  542.1
02520:  BRA    2548
....................             cmdArgs = &impl->cmdBuffer[i];
02522:  MOVLW  12
02524:  ADDWF  540,W
02526:  MOVWF  4E9
02528:  MOVLW  00
0252A:  ADDWFC 541,W
0252C:  MOVWF  4EA
0252E:  MOVFF  4EC,550
02532:  MOVF   4ED,F
02534:  MOVFF  4EF,54F
02538:  MOVF   548,W
0253A:  ADDWF  54F,W
0253C:  MOVWF  501
0253E:  MOVLW  00
02540:  ADDWFC 550,W
02542:  MOVFF  501,546
02546:  MOVWF  547
....................         }
02548:  INCF   548,F
0254A:  BRA    2462
....................     }
.................... 
....................     // we keep two last bytes in cmd buffer reserved so cmdSize is always by 2
....................     // less than cmdMaxSize
....................     impl->cmdBuffer[impl->cmdSize + 1] = '\0';
0254C:  MOVLW  12
0254E:  ADDWF  540,W
02550:  MOVWF  4E9
02552:  MOVLW  00
02554:  ADDWFC 541,W
02556:  MOVWF  4EA
02558:  MOVFF  4EC,550
0255C:  MOVF   4ED,F
0255E:  MOVFF  4EF,54F
02562:  MOVLW  14
02564:  ADDWF  540,W
02566:  MOVWF  4E9
02568:  MOVLW  00
0256A:  ADDWFC 541,W
0256C:  MOVWF  4EA
0256E:  MOVFF  4EC,552
02572:  MOVF   4ED,F
02574:  MOVFF  4EF,551
02578:  MOVLW  01
0257A:  ADDWF  551,F
0257C:  MOVLW  00
0257E:  ADDWFC 552,F
02580:  MOVF   54F,W
02582:  ADDWF  551,W
02584:  MOVWF  4E9
02586:  MOVF   550,W
02588:  ADDWFC 552,W
0258A:  MOVWF  4EA
0258C:  CLRF   4EF
.................... 
....................     if (cmdName == NULL)
0258E:  MOVF   544,F
02590:  BNZ   2598
02592:  MOVF   545,F
02594:  BNZ   2598
....................         return;
02596:  BRA    2866
.................... 
....................     // try to find command in bindings
....................     for (int i = 0; i < impl->bindingsCount; ++i) {
02598:  CLRF   54A
0259A:  MOVLW  1C
0259C:  ADDWF  540,W
0259E:  MOVWF  4E9
025A0:  MOVLW  00
025A2:  ADDWFC 541,W
025A4:  MOVWF  4EA
025A6:  MOVFF  4EC,503
025AA:  MOVF   4ED,F
025AC:  MOVFF  4EF,501
025B0:  MOVF   503,F
025B2:  BNZ   25BC
025B4:  MOVF   501,W
025B6:  SUBWF  54A,W
025B8:  BTFSC  4D8.0
025BA:  BRA    27C2
....................         if (strcmp(cmdName, impl->bindings[i].name) == 0) {
025BC:  MOVLW  18
025BE:  ADDWF  540,W
025C0:  MOVWF  4E9
025C2:  MOVLW  00
025C4:  ADDWFC 541,W
025C6:  MOVWF  4EA
025C8:  MOVFF  4EC,550
025CC:  MOVF   4ED,F
025CE:  MOVFF  4EF,54F
025D2:  MOVLB  5
025D4:  CLRF   xCD
025D6:  MOVFF  54A,5CC
025DA:  CLRF   xCF
025DC:  MOVLW  0B
025DE:  MOVWF  xCE
025E0:  MOVLB  0
025E2:  CALL   004A
025E6:  MOVFF  502,552
025EA:  MOVFF  501,551
025EE:  MOVF   54F,W
025F0:  ADDWF  501,W
025F2:  MOVWF  4E9
025F4:  MOVF   550,W
025F6:  ADDWFC 502,W
025F8:  MOVWF  4EA
025FA:  MOVFF  4EC,5D3
025FE:  MOVF   4ED,F
02600:  MOVFF  4EF,5D2
02604:  MOVFF  545,5D1
02608:  MOVFF  544,5D0
0260C:  CALL   15EC
02610:  MOVF   501,F
02612:  BTFSS  4D8.2
02614:  BRA    27BE
....................             if (impl->bindings[i].binding == NULL)
02616:  MOVLW  18
02618:  ADDWF  540,W
0261A:  MOVWF  4E9
0261C:  MOVLW  00
0261E:  ADDWFC 541,W
02620:  MOVWF  4EA
02622:  MOVFF  4EC,550
02626:  MOVF   4ED,F
02628:  MOVFF  4EF,54F
0262C:  MOVLB  5
0262E:  CLRF   xCD
02630:  MOVFF  54A,5CC
02634:  CLRF   xCF
02636:  MOVLW  0B
02638:  MOVWF  xCE
0263A:  MOVLB  0
0263C:  CALL   004A
02640:  MOVFF  501,551
02644:  MOVLW  07
02646:  ADDWF  501,W
02648:  MOVWF  501
0264A:  MOVLW  00
0264C:  ADDWFC 502,W
0264E:  MOVWF  503
02650:  MOVF   501,W
02652:  ADDWF  54F,W
02654:  MOVWF  4E9
02656:  MOVF   550,W
02658:  ADDWFC 503,W
0265A:  MOVWF  4EA
0265C:  MOVFF  4EF,551
02660:  MOVFF  4EC,552
02664:  MOVFF  4EC,553
02668:  MOVFF  4EC,554
0266C:  MOVF   551,F
0266E:  BNZ   267E
02670:  MOVF   552,F
02672:  BNZ   267E
02674:  MOVF   553,F
02676:  BNZ   267E
02678:  MOVF   554,F
0267A:  BNZ   267E
....................                 break;
0267C:  BRA    27C2
.................... 
....................             if (impl->bindings[i].tokenizeArgs)
0267E:  MOVLW  18
02680:  ADDWF  540,W
02682:  MOVWF  4E9
02684:  MOVLW  00
02686:  ADDWFC 541,W
02688:  MOVWF  4EA
0268A:  MOVFF  4EC,550
0268E:  MOVF   4ED,F
02690:  MOVFF  4EF,54F
02694:  MOVLB  5
02696:  CLRF   xCD
02698:  MOVFF  54A,5CC
0269C:  CLRF   xCF
0269E:  MOVLW  0B
026A0:  MOVWF  xCE
026A2:  MOVLB  0
026A4:  CALL   004A
026A8:  MOVFF  502,552
026AC:  MOVFF  501,551
026B0:  MOVLW  04
026B2:  ADDWF  501,W
026B4:  MOVWF  501
026B6:  MOVLW  00
026B8:  ADDWFC 502,W
026BA:  MOVWF  503
026BC:  MOVF   501,W
026BE:  ADDWF  54F,W
026C0:  MOVWF  4E9
026C2:  MOVF   550,W
026C4:  ADDWFC 503,W
026C6:  MOVWF  4EA
026C8:  BTFSS  4EF.0
026CA:  BRA    26D8
....................                 embeddedCliTokenizeArgs(cmdArgs);
026CC:  MOVFF  547,550
026D0:  MOVFF  546,54F
026D4:  GOTO   1B54
....................             // currently, output is blank line, so we can just print directly
....................             SET_FLAG(impl->flags, CLI_FLAG_DIRECT_PRINT);
026D8:  MOVLW  23
026DA:  ADDWF  540,W
026DC:  MOVWF  4E9
026DE:  MOVLW  00
026E0:  ADDWFC 541,W
026E2:  MOVWF  4EA
026E4:  MOVF   4EF,W
026E6:  IORLW  10
026E8:  MOVWF  4EF
....................             impl->bindings[i].binding(cli, cmdArgs, impl->bindings[i].context);
026EA:  MOVLW  18
026EC:  ADDWF  540,W
026EE:  MOVWF  4E9
026F0:  MOVLW  00
026F2:  ADDWFC 541,W
026F4:  MOVWF  4EA
026F6:  MOVFF  4EC,550
026FA:  MOVF   4ED,F
026FC:  MOVFF  4EF,54F
02700:  MOVLB  5
02702:  CLRF   xCD
02704:  MOVFF  54A,5CC
02708:  CLRF   xCF
0270A:  MOVLW  0B
0270C:  MOVWF  xCE
0270E:  MOVLB  0
02710:  CALL   004A
02714:  MOVFF  502,552
02718:  MOVFF  501,551
0271C:  MOVLW  07
0271E:  ADDWF  501,W
02720:  MOVWF  501
02722:  MOVLW  00
02724:  ADDWFC 502,W
02726:  MOVWF  503
02728:  MOVF   501,W
0272A:  ADDWF  54F,W
0272C:  MOVWF  500
0272E:  MOVF   550,W
02730:  ADDWFC 503,W
02732:  MOVWF  501
02734:  CLRF   502
02736:  BTFSC  4D8.0
02738:  INCF   502,F
0273A:  MOVWF  551
0273C:  CLRF   552
0273E:  MOVLW  18
02740:  ADDWF  540,W
02742:  MOVWF  4E9
02744:  MOVLW  00
02746:  ADDWFC 541,W
02748:  MOVWF  4EA
0274A:  MOVFF  4EC,554
0274E:  MOVF   4ED,F
02750:  MOVFF  4EF,553
02754:  MOVLB  5
02756:  CLRF   xCD
02758:  MOVFF  54A,5CC
0275C:  CLRF   xCF
0275E:  MOVLW  0B
02760:  MOVWF  xCE
02762:  MOVLB  0
02764:  CALL   004A
02768:  MOVFF  501,555
0276C:  MOVLW  05
0276E:  ADDWF  501,W
02770:  MOVWF  501
02772:  MOVLW  00
02774:  ADDWFC 502,W
02776:  MOVWF  503
02778:  MOVF   501,W
0277A:  ADDWF  553,W
0277C:  MOVWF  4E9
0277E:  MOVF   554,W
02780:  ADDWFC 503,W
02782:  MOVWF  4EA
02784:  MOVFF  4EC,52D
02788:  MOVF   4ED,F
0278A:  MOVFF  4EF,52C
0278E:  MOVFF  552,4EA
02792:  MOVFF  551,4E9
02796:  MOVFF  53F,529
0279A:  MOVFF  53E,528
0279E:  MOVFF  547,52B
027A2:  MOVFF  546,52A
027A6:  CALL   0004
....................             UNSET_U8FLAG(impl->flags, CLI_FLAG_DIRECT_PRINT);
027AA:  MOVLW  23
027AC:  ADDWF  540,W
027AE:  MOVWF  4E9
027B0:  MOVLW  00
027B2:  ADDWFC 541,W
027B4:  MOVWF  4EA
027B6:  MOVF   4EF,W
027B8:  ANDLW  EF
027BA:  MOVWF  4EF
....................             return;
027BC:  BRA    2866
....................         }
027BE:  INCF   54A,F
027C0:  BRA    259A
....................     }
.................... 
....................     // command not found in bindings or binding was null
....................     // try to call default callback
....................     if (cli->onCommand != NULL) {
027C2:  MOVLW  04
027C4:  ADDWF  53E,W
027C6:  MOVWF  4E9
027C8:  MOVLW  00
027CA:  ADDWFC 53F,W
027CC:  MOVWF  4EA
027CE:  MOVFF  4EF,54F
027D2:  MOVFF  4EC,550
027D6:  MOVFF  4EC,551
027DA:  MOVFF  4EC,552
027DE:  MOVF   54F,F
027E0:  BNZ   27EE
027E2:  MOVF   550,F
027E4:  BNZ   27EE
027E6:  MOVF   551,F
027E8:  BNZ   27EE
027EA:  MOVF   552,F
027EC:  BZ    2852
....................         CliCommand command;
....................         command.name = cmdName;
027EE:  MOVFF  545,54C
027F2:  MOVFF  544,54B
....................         command.args = cmdArgs;
027F6:  MOVFF  547,54E
027FA:  MOVFF  546,54D
.................... 
....................         // currently, output is blank line, so we can just print directly
....................         SET_FLAG(impl->flags, CLI_FLAG_DIRECT_PRINT);
027FE:  MOVLW  23
02800:  ADDWF  540,W
02802:  MOVWF  4E9
02804:  MOVLW  00
02806:  ADDWFC 541,W
02808:  MOVWF  4EA
0280A:  MOVF   4EF,W
0280C:  IORLW  10
0280E:  MOVWF  4EF
....................         cli->onCommand(cli, &command);
02810:  MOVLW  04
02812:  ADDWF  53E,W
02814:  MOVWF  500
02816:  MOVLW  00
02818:  ADDWFC 53F,W
0281A:  MOVWF  501
0281C:  CLRF   502
0281E:  BTFSC  4D8.0
02820:  INCF   502,F
02822:  MOVWF  54F
02824:  CLRF   550
02826:  CLRF   4EA
02828:  MOVWF  4E9
0282A:  MOVFF  53F,52F
0282E:  MOVFF  53E,52E
02832:  MOVLW  05
02834:  MOVWF  531
02836:  MOVLW  4B
02838:  MOVWF  530
0283A:  CALL   0004
....................         UNSET_U8FLAG(impl->flags, CLI_FLAG_DIRECT_PRINT);
0283E:  MOVLW  23
02840:  ADDWF  540,W
02842:  MOVWF  4E9
02844:  MOVLW  00
02846:  ADDWFC 541,W
02848:  MOVWF  4EA
0284A:  MOVF   4EF,W
0284C:  ANDLW  EF
0284E:  MOVWF  4EF
....................     } else {
02850:  BRA    2866
....................         onUnknownCommand(cli, cmdName);
02852:  MOVFF  53F,5CB
02856:  MOVFF  53E,5CA
0285A:  MOVFF  545,5CD
0285E:  MOVFF  544,5CC
02862:  CALL   1C80
....................     }
02866:  GOTO   2906 (RETURN)
.................... }
.................... 
.................... static void initInternalBindings(EmbeddedCli *cli) {
....................     CliCommandBinding b = {
....................             "help",
*
00294:  MOVLW  68
00296:  MOVWF  550
00298:  MOVLW  65
0029A:  MOVWF  551
0029C:  MOVLW  6C
0029E:  MOVWF  552
002A0:  MOVLW  70
002A2:  MOVWF  553
002A4:  CLRF   554
....................             "Print list of commands",
002A6:  MOVLW  50
002A8:  MOVWF  555
002AA:  MOVLW  72
002AC:  MOVWF  556
002AE:  MOVLW  69
002B0:  MOVWF  557
002B2:  MOVLW  6E
002B4:  MOVWF  558
002B6:  MOVLW  74
002B8:  MOVWF  559
002BA:  MOVLW  20
002BC:  MOVWF  55A
002BE:  MOVLW  6C
002C0:  MOVWF  55B
002C2:  MOVLW  69
002C4:  MOVWF  55C
002C6:  MOVLW  73
002C8:  MOVWF  55D
002CA:  MOVLW  74
002CC:  MOVWF  55E
002CE:  MOVLW  20
002D0:  MOVWF  45F
002D2:  MOVLW  6F
002D4:  MOVLB  5
002D6:  MOVWF  x60
002D8:  MOVLW  66
002DA:  MOVWF  x61
002DC:  MOVLW  20
002DE:  MOVWF  x62
002E0:  MOVLW  63
002E2:  MOVWF  x63
002E4:  MOVLW  6F
002E6:  MOVWF  x64
002E8:  MOVLW  6D
002EA:  MOVWF  x65
002EC:  MOVWF  x66
002EE:  MOVLW  61
002F0:  MOVWF  x67
002F2:  MOVLW  6E
002F4:  MOVWF  x68
002F6:  MOVLW  64
002F8:  MOVWF  x69
002FA:  MOVLW  73
002FC:  MOVWF  x6A
002FE:  CLRF   x6B
....................             true,
....................             NULL,
....................             onHelp
....................     };
00300:  MOVLW  05
00302:  MOVWF  546
00304:  MOVLW  50
00306:  MOVWF  545
00308:  MOVLW  05
0030A:  MOVWF  548
0030C:  MOVLW  55
0030E:  MOVWF  547
00310:  MOVLW  01
00312:  MOVWF  549
00314:  CLRF   54A
00316:  CLRF   54B
00318:  CLRF   54F
0031A:  CLRF   54E
0031C:  MOVLW  1D
0031E:  MOVWF  54D
00320:  MOVLW  E6
00322:  MOVWF  54C
....................     embeddedCliAddBinding(cli, b);
00324:  MOVFF  544,56D
00328:  MOVFF  543,56C
0032C:  MOVFF  545,56E
00330:  MOVFF  546,56F
00334:  MOVFF  547,570
00338:  MOVFF  548,571
0033C:  MOVFF  549,572
00340:  MOVFF  54A,573
00344:  MOVFF  54B,574
00348:  MOVFF  54C,575
0034C:  MOVFF  54D,576
00350:  MOVFF  54E,577
00354:  MOVFF  54F,578
00358:  MOVLB  0
0035A:  BRA    01C8
0035C:  GOTO   0742 (RETURN)
.................... }
.................... 
.................... static void onHelp(EmbeddedCli *cli, char *tokens, void *context) {
....................     UNUSED(context);
....................     PREPARE_IMPL(cli);
*
01DE6:  MOVLW  0A
01DE8:  ADDWF  528,W
01DEA:  MOVWF  4E9
01DEC:  MOVLW  00
01DEE:  ADDWFC 529,W
01DF0:  MOVWF  4EA
01DF2:  MOVFF  4EC,558
01DF6:  MOVF   4ED,F
01DF8:  MOVFF  4EF,557
.................... 
....................     if (impl->bindingsCount == 0) {
01DFC:  MOVLW  1C
01DFE:  ADDWF  557,W
01E00:  MOVWF  4E9
01E02:  MOVLW  00
01E04:  ADDWFC 558,W
01E06:  MOVWF  4EA
01E08:  MOVFF  4EC,5C5
01E0C:  MOVF   4ED,F
01E0E:  MOVFF  4EF,5C4
01E12:  MOVLB  5
01E14:  MOVF   xC4,F
01E16:  BNZ   1EA2
01E18:  MOVF   xC5,F
01E1A:  BNZ   1EA2
....................         char help[] = "Help is not available";
01E1C:  MOVLW  48
01E1E:  MOVWF  559
01E20:  MOVLW  65
01E22:  MOVWF  55A
01E24:  MOVLW  6C
01E26:  MOVWF  55B
01E28:  MOVLW  70
01E2A:  MOVWF  55C
01E2C:  MOVLW  20
01E2E:  MOVWF  55D
01E30:  MOVLW  69
01E32:  MOVWF  55E
01E34:  MOVLW  73
01E36:  MOVWF  45F
01E38:  MOVLW  20
01E3A:  MOVWF  x60
01E3C:  MOVLW  6E
01E3E:  MOVWF  x61
01E40:  MOVLW  6F
01E42:  MOVWF  x62
01E44:  MOVLW  74
01E46:  MOVWF  x63
01E48:  MOVLW  20
01E4A:  MOVWF  x64
01E4C:  MOVLW  61
01E4E:  MOVWF  x65
01E50:  MOVLW  76
01E52:  MOVWF  x66
01E54:  MOVLW  61
01E56:  MOVWF  x67
01E58:  MOVLW  69
01E5A:  MOVWF  x68
01E5C:  MOVLW  6C
01E5E:  MOVWF  x69
01E60:  MOVLW  61
01E62:  MOVWF  x6A
01E64:  MOVLW  62
01E66:  MOVWF  x6B
01E68:  MOVLW  6C
01E6A:  MOVWF  x6C
01E6C:  MOVLW  65
01E6E:  MOVWF  x6D
01E70:  CLRF   x6E
....................         writeToOutput(cli, help);
01E72:  MOVFF  529,613
01E76:  MOVFF  528,612
01E7A:  MOVLW  05
01E7C:  MOVLB  6
01E7E:  MOVWF  x15
01E80:  MOVLW  59
01E82:  MOVWF  x14
01E84:  MOVLB  0
01E86:  CALL   07A2
....................         writeToOutput(cli, lineBreak);
01E8A:  MOVFF  529,613
01E8E:  MOVFF  528,612
01E92:  MOVFF  51C,615
01E96:  MOVFF  51B,614
01E9A:  CALL   07A2
....................         return;
01E9E:  BRA    23AA
01EA0:  MOVLB  5
....................     }
.................... 
....................     uint16_t tokenCount = embeddedCliGetTokenCount(tokens);
01EA2:  MOVFF  52B,5CB
01EA6:  MOVFF  52A,5CA
01EAA:  MOVLB  0
01EAC:  BRA    1C1E
01EAE:  MOVFF  502,570
01EB2:  MOVFF  501,56F
....................     if (tokenCount == 0) {
01EB6:  MOVLB  5
01EB8:  MOVF   x6F,F
01EBA:  BTFSS  4D8.2
01EBC:  BRA    2074
01EBE:  MOVF   x70,F
01EC0:  BTFSS  4D8.2
01EC2:  BRA    2074
....................         for (int i = 0; i < impl->bindingsCount; ++i) {
01EC4:  CLRF   x71
01EC6:  MOVLW  1C
01EC8:  ADDWF  557,W
01ECA:  MOVWF  4E9
01ECC:  MOVLW  00
01ECE:  ADDWFC 558,W
01ED0:  MOVWF  4EA
01ED2:  MOVFF  4EC,503
01ED6:  MOVF   4ED,F
01ED8:  MOVFF  4EF,501
01EDC:  MOVF   503,F
01EDE:  BNZ   1EE8
01EE0:  MOVF   501,W
01EE2:  SUBWF  x71,W
01EE4:  BTFSC  4D8.0
01EE6:  BRA    2072
....................             char star[] = " * ";
01EE8:  MOVLW  20
01EEA:  MOVWF  x72
01EEC:  MOVLW  2A
01EEE:  MOVWF  x73
01EF0:  MOVLW  20
01EF2:  MOVWF  x74
01EF4:  CLRF   x75
....................             writeToOutput(cli, star);
01EF6:  MOVFF  529,613
01EFA:  MOVFF  528,612
01EFE:  MOVLW  05
01F00:  MOVLB  6
01F02:  MOVWF  x15
01F04:  MOVLW  72
01F06:  MOVWF  x14
01F08:  MOVLB  0
01F0A:  CALL   07A2
....................             writeToOutput(cli, impl->bindings[i].name);
01F0E:  MOVLW  18
01F10:  ADDWF  557,W
01F12:  MOVWF  4E9
01F14:  MOVLW  00
01F16:  ADDWFC 558,W
01F18:  MOVWF  4EA
01F1A:  MOVFF  4EC,5C5
01F1E:  MOVF   4ED,F
01F20:  MOVFF  4EF,5C4
01F24:  MOVLB  5
01F26:  CLRF   xCD
01F28:  MOVFF  571,5CC
01F2C:  CLRF   xCF
01F2E:  MOVLW  0B
01F30:  MOVWF  xCE
01F32:  MOVLB  0
01F34:  CALL   004A
01F38:  MOVFF  502,5C7
01F3C:  MOVFF  501,5C6
01F40:  MOVLB  5
01F42:  MOVF   xC4,W
01F44:  ADDWF  501,W
01F46:  MOVWF  4E9
01F48:  MOVF   xC5,W
01F4A:  ADDWFC 502,W
01F4C:  MOVWF  4EA
01F4E:  MOVFF  4EC,615
01F52:  MOVF   4ED,F
01F54:  MOVFF  4EF,614
01F58:  MOVFF  529,613
01F5C:  MOVFF  528,612
01F60:  MOVLB  0
01F62:  CALL   07A2
....................             writeToOutput(cli, lineBreak);
01F66:  MOVFF  529,613
01F6A:  MOVFF  528,612
01F6E:  MOVFF  51C,615
01F72:  MOVFF  51B,614
01F76:  CALL   07A2
....................             if (impl->bindings[i].help != NULL) {
01F7A:  MOVLW  18
01F7C:  ADDWF  557,W
01F7E:  MOVWF  4E9
01F80:  MOVLW  00
01F82:  ADDWFC 558,W
01F84:  MOVWF  4EA
01F86:  MOVFF  4EC,5C5
01F8A:  MOVF   4ED,F
01F8C:  MOVFF  4EF,5C4
01F90:  MOVLB  5
01F92:  CLRF   xCD
01F94:  MOVFF  571,5CC
01F98:  CLRF   xCF
01F9A:  MOVLW  0B
01F9C:  MOVWF  xCE
01F9E:  MOVLB  0
01FA0:  CALL   004A
01FA4:  MOVFF  501,5C6
01FA8:  MOVLW  02
01FAA:  MOVLB  5
01FAC:  ADDWF  501,W
01FAE:  MOVWF  501
01FB0:  MOVLW  00
01FB2:  ADDWFC 502,W
01FB4:  MOVWF  503
01FB6:  MOVF   501,W
01FB8:  ADDWF  xC4,W
01FBA:  MOVWF  4E9
01FBC:  MOVF   xC5,W
01FBE:  ADDWFC 503,W
01FC0:  MOVWF  4EA
01FC2:  MOVFF  4EC,5C7
01FC6:  MOVF   4ED,F
01FC8:  MOVFF  4EF,5C6
01FCC:  MOVF   xC6,F
01FCE:  BNZ   1FD4
01FD0:  MOVF   xC7,F
01FD2:  BZ    206E
....................                 cli->writeChar(cli, '\t');
01FD4:  MOVFF  528,500
01FD8:  MOVF   529,W
01FDA:  MOVWF  501
01FDC:  CLRF   502
01FDE:  MOVWF  xC4
01FE0:  CLRF   xC5
01FE2:  CLRF   4EA
01FE4:  MOVWF  4E9
01FE6:  MOVFF  529,526
01FEA:  MOVFF  528,525
01FEE:  MOVLW  09
01FF0:  MOVWF  527
01FF2:  MOVLB  0
01FF4:  CALL   0004
....................                 writeToOutput(cli, impl->bindings[i].help);
01FF8:  MOVLW  18
01FFA:  ADDWF  557,W
01FFC:  MOVWF  4E9
01FFE:  MOVLW  00
02000:  ADDWFC 558,W
02002:  MOVWF  4EA
02004:  MOVFF  4EC,5C5
02008:  MOVF   4ED,F
0200A:  MOVFF  4EF,5C4
0200E:  MOVLB  5
02010:  CLRF   xCD
02012:  MOVFF  571,5CC
02016:  CLRF   xCF
02018:  MOVLW  0B
0201A:  MOVWF  xCE
0201C:  MOVLB  0
0201E:  CALL   004A
02022:  MOVFF  501,5C6
02026:  MOVLW  02
02028:  MOVLB  5
0202A:  ADDWF  501,W
0202C:  MOVWF  501
0202E:  MOVLW  00
02030:  ADDWFC 502,W
02032:  MOVWF  503
02034:  MOVF   501,W
02036:  ADDWF  xC4,W
02038:  MOVWF  4E9
0203A:  MOVF   xC5,W
0203C:  ADDWFC 503,W
0203E:  MOVWF  4EA
02040:  MOVFF  4EC,615
02044:  MOVF   4ED,F
02046:  MOVFF  4EF,614
0204A:  MOVFF  529,613
0204E:  MOVFF  528,612
02052:  MOVLB  0
02054:  CALL   07A2
....................                 writeToOutput(cli, lineBreak);
02058:  MOVFF  529,613
0205C:  MOVFF  528,612
02060:  MOVFF  51C,615
02064:  MOVFF  51B,614
02068:  CALL   07A2
0206C:  MOVLB  5
....................             }
0206E:  INCF   x71,F
02070:  BRA    1EC6
....................         }
....................     } else if (tokenCount == 1) {
02072:  BRA    23AC
02074:  DECFSZ x6F,W
02076:  BRA    22CA
02078:  MOVF   x70,F
0207A:  BTFSS  4D8.2
0207C:  BRA    22CA
....................         // try find command
....................         char *helpStr = NULL;
....................         char *cmdName = embeddedCliGetToken(tokens, 1);
....................         bool found = false;
0207E:  CLRF   x77
02080:  CLRF   x76
02082:  MOVFF  52B,5CB
02086:  MOVFF  52A,5CA
0208A:  CLRF   xCD
0208C:  MOVLW  01
0208E:  MOVWF  xCC
02090:  MOVLB  0
02092:  CALL   0B6A
02096:  MOVFF  502,579
0209A:  MOVFF  501,578
0209E:  MOVLB  5
020A0:  BCF    x7A.0
....................         for (int i = 0; i < impl->bindingsCount; ++i) {
020A2:  CLRF   x7B
020A4:  MOVLW  1C
020A6:  ADDWF  557,W
020A8:  MOVWF  4E9
020AA:  MOVLW  00
020AC:  ADDWFC 558,W
020AE:  MOVWF  4EA
020B0:  MOVFF  4EC,503
020B4:  MOVF   4ED,F
020B6:  MOVFF  4EF,501
020BA:  MOVF   503,F
020BC:  BNZ   20C4
020BE:  MOVF   501,W
020C0:  SUBWF  x7B,W
020C2:  BC    217C
....................             if (strcmp(impl->bindings[i].name, cmdName) == 0) {
020C4:  MOVLW  18
020C6:  ADDWF  557,W
020C8:  MOVWF  4E9
020CA:  MOVLW  00
020CC:  ADDWFC 558,W
020CE:  MOVWF  4EA
020D0:  MOVFF  4EC,5C5
020D4:  MOVF   4ED,F
020D6:  MOVFF  4EF,5C4
020DA:  CLRF   xCD
020DC:  MOVFF  57B,5CC
020E0:  CLRF   xCF
020E2:  MOVLW  0B
020E4:  MOVWF  xCE
020E6:  MOVLB  0
020E8:  CALL   004A
020EC:  MOVFF  502,5C7
020F0:  MOVFF  501,5C6
020F4:  MOVLB  5
020F6:  MOVF   xC4,W
020F8:  ADDWF  501,W
020FA:  MOVWF  4E9
020FC:  MOVF   xC5,W
020FE:  ADDWFC 502,W
02100:  MOVWF  4EA
02102:  MOVFF  4EC,5D1
02106:  MOVF   4ED,F
02108:  MOVFF  4EF,5D0
0210C:  MOVFF  579,5D3
02110:  MOVFF  578,5D2
02114:  MOVLB  0
02116:  CALL   15EC
0211A:  MOVF   501,F
0211C:  BNZ   2176
....................                 helpStr = impl->bindings[i].help;
0211E:  MOVLW  18
02120:  ADDWF  557,W
02122:  MOVWF  4E9
02124:  MOVLW  00
02126:  ADDWFC 558,W
02128:  MOVWF  4EA
0212A:  MOVFF  4EC,5C5
0212E:  MOVF   4ED,F
02130:  MOVFF  4EF,5C4
02134:  MOVLB  5
02136:  CLRF   xCD
02138:  MOVFF  57B,5CC
0213C:  CLRF   xCF
0213E:  MOVLW  0B
02140:  MOVWF  xCE
02142:  MOVLB  0
02144:  CALL   004A
02148:  MOVFF  501,5C6
0214C:  MOVLW  02
0214E:  MOVLB  5
02150:  ADDWF  501,W
02152:  MOVWF  501
02154:  MOVLW  00
02156:  ADDWFC 502,W
02158:  MOVWF  503
0215A:  MOVF   501,W
0215C:  ADDWF  xC4,W
0215E:  MOVWF  4E9
02160:  MOVF   xC5,W
02162:  ADDWFC 503,W
02164:  MOVWF  4EA
02166:  MOVFF  4EC,577
0216A:  MOVF   4ED,F
0216C:  MOVFF  4EF,576
....................                 found = true;
02170:  BSF    x7A.0
....................                 break;
02172:  BRA    217C
02174:  MOVLB  0
....................             }
02176:  MOVLB  5
02178:  INCF   x7B,F
0217A:  BRA    20A4
....................         }
....................         if (found && helpStr != NULL) {
0217C:  BTFSS  x7A.0
0217E:  BRA    2228
02180:  MOVF   x76,F
02182:  BNZ   2188
02184:  MOVF   x77,F
02186:  BZ    2228
....................             char star[] = " * ";
02188:  MOVLW  20
0218A:  MOVWF  x7C
0218C:  MOVLW  2A
0218E:  MOVWF  x7D
02190:  MOVLW  20
02192:  MOVWF  x7E
02194:  CLRF   x7F
....................             writeToOutput(cli, star);
02196:  MOVFF  529,613
0219A:  MOVFF  528,612
0219E:  MOVLW  05
021A0:  MOVLB  6
021A2:  MOVWF  x15
021A4:  MOVLW  7C
021A6:  MOVWF  x14
021A8:  MOVLB  0
021AA:  CALL   07A2
....................             writeToOutput(cli, cmdName);
021AE:  MOVFF  529,613
021B2:  MOVFF  528,612
021B6:  MOVFF  579,615
021BA:  MOVFF  578,614
021BE:  CALL   07A2
....................             writeToOutput(cli, lineBreak);
021C2:  MOVFF  529,613
021C6:  MOVFF  528,612
021CA:  MOVFF  51C,615
021CE:  MOVFF  51B,614
021D2:  CALL   07A2
....................             cli->writeChar(cli, '\t');
021D6:  MOVFF  528,500
021DA:  MOVF   529,W
021DC:  MOVWF  501
021DE:  CLRF   502
021E0:  MOVLB  5
021E2:  MOVWF  xC4
021E4:  CLRF   xC5
021E6:  CLRF   4EA
021E8:  MOVWF  4E9
021EA:  MOVFF  529,526
021EE:  MOVFF  528,525
021F2:  MOVLW  09
021F4:  MOVWF  527
021F6:  MOVLB  0
021F8:  CALL   0004
....................             writeToOutput(cli, helpStr);
021FC:  MOVFF  529,613
02200:  MOVFF  528,612
02204:  MOVFF  577,615
02208:  MOVFF  576,614
0220C:  CALL   07A2
....................             writeToOutput(cli, lineBreak);
02210:  MOVFF  529,613
02214:  MOVFF  528,612
02218:  MOVFF  51C,615
0221C:  MOVFF  51B,614
02220:  CALL   07A2
....................         } else if (found) {
02224:  BRA    22C6
02226:  MOVLB  5
02228:  BTFSS  x7A.0
0222A:  BRA    22B2
....................             char help[] = "Help is not available";
0222C:  MOVLW  48
0222E:  MOVWF  x80
02230:  MOVLW  65
02232:  MOVWF  x81
02234:  MOVLW  6C
02236:  MOVWF  x82
02238:  MOVLW  70
0223A:  MOVWF  x83
0223C:  MOVLW  20
0223E:  MOVWF  x84
02240:  MOVLW  69
02242:  MOVWF  x85
02244:  MOVLW  73
02246:  MOVWF  x86
02248:  MOVLW  20
0224A:  MOVWF  x87
0224C:  MOVLW  6E
0224E:  MOVWF  x88
02250:  MOVLW  6F
02252:  MOVWF  x89
02254:  MOVLW  74
02256:  MOVWF  x8A
02258:  MOVLW  20
0225A:  MOVWF  x8B
0225C:  MOVLW  61
0225E:  MOVWF  x8C
02260:  MOVLW  76
02262:  MOVWF  x8D
02264:  MOVLW  61
02266:  MOVWF  x8E
02268:  MOVLW  69
0226A:  MOVWF  x8F
0226C:  MOVLW  6C
0226E:  MOVWF  x90
02270:  MOVLW  61
02272:  MOVWF  x91
02274:  MOVLW  62
02276:  MOVWF  x92
02278:  MOVLW  6C
0227A:  MOVWF  x93
0227C:  MOVLW  65
0227E:  MOVWF  x94
02280:  CLRF   x95
....................             writeToOutput(cli, help);
02282:  MOVFF  529,613
02286:  MOVFF  528,612
0228A:  MOVLW  05
0228C:  MOVLB  6
0228E:  MOVWF  x15
02290:  MOVLW  80
02292:  MOVWF  x14
02294:  MOVLB  0
02296:  CALL   07A2
....................             writeToOutput(cli, lineBreak);
0229A:  MOVFF  529,613
0229E:  MOVFF  528,612
022A2:  MOVFF  51C,615
022A6:  MOVFF  51B,614
022AA:  CALL   07A2
....................         } else {
022AE:  BRA    22C6
022B0:  MOVLB  5
....................             onUnknownCommand(cli, cmdName);
022B2:  MOVFF  529,5CB
022B6:  MOVFF  528,5CA
022BA:  MOVFF  579,5CD
022BE:  MOVFF  578,5CC
022C2:  MOVLB  0
022C4:  RCALL  1C80
....................         }
....................     } else {
022C6:  BRA    23AA
022C8:  MOVLB  5
....................         char help[] = "Command \"help\" receives one or zero arguments";
022CA:  MOVLW  43
022CC:  MOVWF  x96
022CE:  MOVLW  6F
022D0:  MOVWF  x97
022D2:  MOVLW  6D
022D4:  MOVWF  x98
022D6:  MOVWF  x99
022D8:  MOVLW  61
022DA:  MOVWF  x9A
022DC:  MOVLW  6E
022DE:  MOVWF  x9B
022E0:  MOVLW  64
022E2:  MOVWF  x9C
022E4:  MOVLW  20
022E6:  MOVWF  x9D
022E8:  MOVLW  22
022EA:  MOVWF  x9E
022EC:  MOVLW  68
022EE:  MOVWF  x9F
022F0:  MOVLW  65
022F2:  MOVWF  xA0
022F4:  MOVLW  6C
022F6:  MOVWF  xA1
022F8:  MOVLW  70
022FA:  MOVWF  xA2
022FC:  MOVLW  22
022FE:  MOVWF  xA3
02300:  MOVLW  20
02302:  MOVWF  xA4
02304:  MOVLW  72
02306:  MOVWF  xA5
02308:  MOVLW  65
0230A:  MOVWF  xA6
0230C:  MOVLW  63
0230E:  MOVWF  xA7
02310:  MOVLW  65
02312:  MOVWF  xA8
02314:  MOVLW  69
02316:  MOVWF  xA9
02318:  MOVLW  76
0231A:  MOVWF  xAA
0231C:  MOVLW  65
0231E:  MOVWF  xAB
02320:  MOVLW  73
02322:  MOVWF  xAC
02324:  MOVLW  20
02326:  MOVWF  xAD
02328:  MOVLW  6F
0232A:  MOVWF  xAE
0232C:  MOVLW  6E
0232E:  MOVWF  xAF
02330:  MOVLW  65
02332:  MOVWF  xB0
02334:  MOVLW  20
02336:  MOVWF  xB1
02338:  MOVLW  6F
0233A:  MOVWF  xB2
0233C:  MOVLW  72
0233E:  MOVWF  xB3
02340:  MOVLW  20
02342:  MOVWF  xB4
02344:  MOVLW  7A
02346:  MOVWF  xB5
02348:  MOVLW  65
0234A:  MOVWF  xB6
0234C:  MOVLW  72
0234E:  MOVWF  xB7
02350:  MOVLW  6F
02352:  MOVWF  xB8
02354:  MOVLW  20
02356:  MOVWF  xB9
02358:  MOVLW  61
0235A:  MOVWF  xBA
0235C:  MOVLW  72
0235E:  MOVWF  xBB
02360:  MOVLW  67
02362:  MOVWF  xBC
02364:  MOVLW  75
02366:  MOVWF  xBD
02368:  MOVLW  6D
0236A:  MOVWF  xBE
0236C:  MOVLW  65
0236E:  MOVWF  xBF
02370:  MOVLW  6E
02372:  MOVWF  xC0
02374:  MOVLW  74
02376:  MOVWF  xC1
02378:  MOVLW  73
0237A:  MOVWF  xC2
0237C:  CLRF   xC3
....................         writeToOutput(cli, help);
0237E:  MOVFF  529,613
02382:  MOVFF  528,612
02386:  MOVLW  05
02388:  MOVLB  6
0238A:  MOVWF  x15
0238C:  MOVLW  96
0238E:  MOVWF  x14
02390:  MOVLB  0
02392:  CALL   07A2
....................         writeToOutput(cli, lineBreak);
02396:  MOVFF  529,613
0239A:  MOVFF  528,612
0239E:  MOVFF  51C,615
023A2:  MOVFF  51B,614
023A6:  CALL   07A2
023AA:  MOVLB  5
....................     }
023AC:  MOVLB  0
023AE:  RETURN 0
.................... }
.................... 
.................... static void onUnknownCommand(EmbeddedCli *cli, char *name) {
....................     char unknown[] = "Unknown command: \"";
*
01C80:  MOVLW  55
01C82:  MOVLB  5
01C84:  MOVWF  xCE
01C86:  MOVLW  6E
01C88:  MOVWF  xCF
01C8A:  MOVLW  6B
01C8C:  MOVWF  xD0
01C8E:  MOVLW  6E
01C90:  MOVWF  xD1
01C92:  MOVLW  6F
01C94:  MOVWF  xD2
01C96:  MOVLW  77
01C98:  MOVWF  xD3
01C9A:  MOVLW  6E
01C9C:  MOVWF  xD4
01C9E:  MOVLW  20
01CA0:  MOVWF  xD5
01CA2:  MOVLW  63
01CA4:  MOVWF  xD6
01CA6:  MOVLW  6F
01CA8:  MOVWF  xD7
01CAA:  MOVLW  6D
01CAC:  MOVWF  xD8
01CAE:  MOVWF  xD9
01CB0:  MOVLW  61
01CB2:  MOVWF  xDA
01CB4:  MOVLW  6E
01CB6:  MOVWF  xDB
01CB8:  MOVLW  64
01CBA:  MOVWF  xDC
01CBC:  MOVLW  3A
01CBE:  MOVWF  xDD
01CC0:  MOVLW  20
01CC2:  MOVWF  xDE
01CC4:  MOVLW  22
01CC6:  MOVWF  xDF
01CC8:  CLRF   xE0
....................     writeToOutput(cli, unknown);
01CCA:  MOVFF  5CB,613
01CCE:  MOVFF  5CA,612
01CD2:  MOVLW  05
01CD4:  MOVLB  6
01CD6:  MOVWF  x15
01CD8:  MOVLW  CE
01CDA:  MOVWF  x14
01CDC:  MOVLB  0
01CDE:  CALL   07A2
....................     writeToOutput(cli, name);
01CE2:  MOVFF  5CB,613
01CE6:  MOVFF  5CA,612
01CEA:  MOVFF  5CD,615
01CEE:  MOVFF  5CC,614
01CF2:  CALL   07A2
....................     char help[] = "\". Write \"help\" for a list of available commands";
01CF6:  MOVLW  22
01CF8:  MOVLB  5
01CFA:  MOVWF  xE1
01CFC:  MOVLW  2E
01CFE:  MOVWF  xE2
01D00:  MOVLW  20
01D02:  MOVWF  xE3
01D04:  MOVLW  57
01D06:  MOVWF  xE4
01D08:  MOVLW  72
01D0A:  MOVWF  xE5
01D0C:  MOVLW  69
01D0E:  MOVWF  xE6
01D10:  MOVLW  74
01D12:  MOVWF  xE7
01D14:  MOVLW  65
01D16:  MOVWF  xE8
01D18:  MOVLW  20
01D1A:  MOVWF  xE9
01D1C:  MOVLW  22
01D1E:  MOVWF  xEA
01D20:  MOVLW  68
01D22:  MOVWF  xEB
01D24:  MOVLW  65
01D26:  MOVWF  xEC
01D28:  MOVLW  6C
01D2A:  MOVWF  xED
01D2C:  MOVLW  70
01D2E:  MOVWF  xEE
01D30:  MOVLW  22
01D32:  MOVWF  xEF
01D34:  MOVLW  20
01D36:  MOVWF  xF0
01D38:  MOVLW  66
01D3A:  MOVWF  xF1
01D3C:  MOVLW  6F
01D3E:  MOVWF  xF2
01D40:  MOVLW  72
01D42:  MOVWF  xF3
01D44:  MOVLW  20
01D46:  MOVWF  xF4
01D48:  MOVLW  61
01D4A:  MOVWF  xF5
01D4C:  MOVLW  20
01D4E:  MOVWF  xF6
01D50:  MOVLW  6C
01D52:  MOVWF  xF7
01D54:  MOVLW  69
01D56:  MOVWF  xF8
01D58:  MOVLW  73
01D5A:  MOVWF  xF9
01D5C:  MOVLW  74
01D5E:  MOVWF  xFA
01D60:  MOVLW  20
01D62:  MOVWF  xFB
01D64:  MOVLW  6F
01D66:  MOVWF  xFC
01D68:  MOVLW  66
01D6A:  MOVWF  xFD
01D6C:  MOVLW  20
01D6E:  MOVWF  xFE
01D70:  MOVLW  61
01D72:  MOVWF  xFF
01D74:  MOVLW  76
01D76:  MOVLB  6
01D78:  MOVWF  x00
01D7A:  MOVLW  61
01D7C:  MOVWF  x01
01D7E:  MOVLW  69
01D80:  MOVWF  x02
01D82:  MOVLW  6C
01D84:  MOVWF  x03
01D86:  MOVLW  61
01D88:  MOVWF  x04
01D8A:  MOVLW  62
01D8C:  MOVWF  x05
01D8E:  MOVLW  6C
01D90:  MOVWF  x06
01D92:  MOVLW  65
01D94:  MOVWF  x07
01D96:  MOVLW  20
01D98:  MOVWF  x08
01D9A:  MOVLW  63
01D9C:  MOVWF  x09
01D9E:  MOVLW  6F
01DA0:  MOVWF  x0A
01DA2:  MOVLW  6D
01DA4:  MOVWF  x0B
01DA6:  MOVWF  x0C
01DA8:  MOVLW  61
01DAA:  MOVWF  x0D
01DAC:  MOVLW  6E
01DAE:  MOVWF  x0E
01DB0:  MOVLW  64
01DB2:  MOVWF  x0F
01DB4:  MOVLW  73
01DB6:  MOVWF  x10
01DB8:  CLRF   x11
....................     writeToOutput(cli, help);
01DBA:  MOVFF  5CB,613
01DBE:  MOVFF  5CA,612
01DC2:  MOVLW  05
01DC4:  MOVWF  x15
01DC6:  MOVLW  E1
01DC8:  MOVWF  x14
01DCA:  MOVLB  0
01DCC:  CALL   07A2
....................     writeToOutput(cli, lineBreak);
01DD0:  MOVFF  5CB,613
01DD4:  MOVFF  5CA,612
01DD8:  MOVFF  51C,615
01DDC:  MOVFF  51B,614
01DE0:  CALL   07A2
01DE4:  RETURN 0
.................... }
.................... 
.................... static AutocompletedCommand getAutocompletedCommand(EmbeddedCli *cli, char *prefix) {
*
00C16:  MOVFF  561,61B
00C1A:  MOVFF  560,61A
00C1E:  MOVLB  0
00C20:  RCALL  0768
00C22:  MOVFF  502,569
00C26:  MOVFF  501,568
00C2A:  MOVLW  0A
00C2C:  ADDWF  55E,W
00C2E:  MOVWF  4E9
00C30:  MOVLW  00
00C32:  ADDWFC 45F,W
00C34:  MOVWF  4EA
00C36:  MOVFF  4EC,56B
00C3A:  MOVF   4ED,F
00C3C:  MOVFF  4EF,56A
00C40:  MOVLB  5
....................     AutocompletedCommand cmd = {NULL, 0, 0};
*
00C08:  MOVLB  5
00C0A:  CLRF   x62
00C0C:  CLRF   x63
00C0E:  CLRF   x64
00C10:  CLRF   x65
00C12:  CLRF   x66
00C14:  CLRF   x67
.................... 
....................     size_t prefixLen = strlen(prefix);
.................... 
....................     PREPARE_IMPL(cli);
....................     if (impl->bindingsCount == 0 || prefixLen == 0)
*
00C42:  MOVLW  1C
00C44:  ADDWF  x6A,W
00C46:  MOVWF  4E9
00C48:  MOVLW  00
00C4A:  ADDWFC x6B,W
00C4C:  MOVWF  4EA
00C4E:  MOVFF  4EC,577
00C52:  MOVF   4ED,F
00C54:  MOVFF  4EF,576
00C58:  MOVF   x76,F
00C5A:  BNZ   0C60
00C5C:  MOVF   x77,F
00C5E:  BZ    0C68
00C60:  MOVF   x68,F
00C62:  BNZ   0C72
00C64:  MOVF   x69,F
00C66:  BNZ   0C72
....................         return cmd;
00C68:  MOVLW  62
00C6A:  MOVWF  501
00C6C:  MOVLW  05
00C6E:  MOVWF  502
00C70:  BRA    0E36
.................... 
.................... 
....................     for (int i = 0; i < impl->bindingsCount; ++i) {
00C72:  CLRF   x6C
00C74:  MOVLW  1C
00C76:  ADDWF  x6A,W
00C78:  MOVWF  4E9
00C7A:  MOVLW  00
00C7C:  ADDWFC x6B,W
00C7E:  MOVWF  4EA
00C80:  MOVFF  4EC,503
00C84:  MOVF   4ED,F
00C86:  MOVFF  4EF,501
00C8A:  MOVF   503,F
00C8C:  BNZ   0C96
00C8E:  MOVF   501,W
00C90:  SUBWF  x6C,W
00C92:  BTFSC  4D8.0
00C94:  BRA    0E2E
....................         char *name = impl->bindings[i].name;
....................         size_t len = strlen(name);
00C96:  MOVLW  18
00C98:  ADDWF  x6A,W
00C9A:  MOVWF  4E9
00C9C:  MOVLW  00
00C9E:  ADDWFC x6B,W
00CA0:  MOVWF  4EA
00CA2:  MOVFF  4EC,577
00CA6:  MOVF   4ED,F
00CA8:  MOVFF  4EF,576
00CAC:  CLRF   xCD
00CAE:  MOVFF  56C,5CC
00CB2:  CLRF   xCF
00CB4:  MOVLW  0B
00CB6:  MOVWF  xCE
00CB8:  MOVLB  0
00CBA:  CALL   004A
00CBE:  MOVFF  502,579
00CC2:  MOVFF  501,578
00CC6:  MOVLB  5
00CC8:  MOVF   x76,W
00CCA:  ADDWF  501,W
00CCC:  MOVWF  4E9
00CCE:  MOVF   x77,W
00CD0:  ADDWFC 502,W
00CD2:  MOVWF  4EA
00CD4:  MOVFF  4EC,56E
00CD8:  MOVF   4ED,F
00CDA:  MOVFF  4EF,56D
00CDE:  MOVFF  56E,61B
00CE2:  MOVFF  56D,61A
00CE6:  MOVLB  0
00CE8:  RCALL  0768
00CEA:  MOVFF  502,570
00CEE:  MOVFF  501,56F
.................... 
....................         // unset autocomplete flag
....................         UNSET_U8FLAG(impl->bindingsFlags[i], BINDING_FLAG_AUTOCOMPLETE);
00CF2:  MOVLW  1A
00CF4:  MOVLB  5
00CF6:  ADDWF  x6A,W
00CF8:  MOVWF  4E9
00CFA:  MOVLW  00
00CFC:  ADDWFC x6B,W
00CFE:  MOVWF  4EA
00D00:  MOVFF  4EC,577
00D04:  MOVF   4ED,F
00D06:  MOVFF  4EF,576
00D0A:  MOVF   x6C,W
00D0C:  ADDWF  x76,W
00D0E:  MOVWF  4E9
00D10:  MOVLW  00
00D12:  ADDWFC x77,W
00D14:  MOVWF  4EA
00D16:  MOVF   4EF,W
00D18:  ANDLW  FE
00D1A:  MOVWF  4EF
.................... 
....................         if (len < prefixLen)
00D1C:  MOVF   x70,W
00D1E:  SUBWF  x69,W
00D20:  BNC   0D2C
00D22:  BNZ   0D2A
00D24:  MOVF   x68,W
00D26:  SUBWF  x6F,W
00D28:  BC    0D2C
....................             continue;
00D2A:  BRA    0E2A
.................... 
....................         // check if this command is candidate for autocomplete
....................         bool isCandidate = true;
00D2C:  BSF    x71.0
....................         for (size_t j = 0; j < prefixLen; ++j) {
00D2E:  CLRF   x73
00D30:  CLRF   x72
00D32:  MOVF   x73,W
00D34:  SUBWF  x69,W
00D36:  BNC   0D6E
00D38:  BNZ   0D40
00D3A:  MOVF   x68,W
00D3C:  SUBWF  x72,W
00D3E:  BC    0D6E
....................             if (prefix[j] != name[j]) {
00D40:  MOVF   x60,W
00D42:  ADDWF  x72,W
00D44:  MOVWF  4E9
00D46:  MOVF   x61,W
00D48:  ADDWFC x73,W
00D4A:  MOVWF  4EA
00D4C:  MOVFF  4EF,576
00D50:  MOVF   x6D,W
00D52:  ADDWF  x72,W
00D54:  MOVWF  4E9
00D56:  MOVF   x6E,W
00D58:  ADDWFC x73,W
00D5A:  MOVWF  4EA
00D5C:  MOVF   4EF,W
00D5E:  SUBWF  x76,W
00D60:  BZ    0D66
....................                 isCandidate = false;
00D62:  BCF    x71.0
....................                 break;
00D64:  BRA    0D6E
....................             }
00D66:  INCF   x72,F
00D68:  BTFSC  4D8.2
00D6A:  INCF   x73,F
00D6C:  BRA    0D32
....................         }
....................         if (!isCandidate)
00D6E:  BTFSC  x71.0
00D70:  BRA    0D74
....................             continue;
00D72:  BRA    0E2A
.................... 
....................         impl->bindingsFlags[i] |= BINDING_FLAG_AUTOCOMPLETE;
00D74:  MOVLW  1A
00D76:  ADDWF  x6A,W
00D78:  MOVWF  4E9
00D7A:  MOVLW  00
00D7C:  ADDWFC x6B,W
00D7E:  MOVWF  4EA
00D80:  MOVFF  4EC,577
00D84:  MOVF   4ED,F
00D86:  MOVFF  4EF,576
00D8A:  MOVF   x6C,W
00D8C:  ADDWF  x76,W
00D8E:  MOVWF  4E9
00D90:  MOVLW  00
00D92:  ADDWFC x77,W
00D94:  MOVWF  4EA
00D96:  MOVF   4EF,W
00D98:  IORLW  01
00D9A:  MOVWF  4EF
.................... 
....................         if (cmd.candidateCount == 0 || len < cmd.autocompletedLen)
00D9C:  MOVF   x66,F
00D9E:  BNZ   0DA4
00DA0:  MOVF   x67,F
00DA2:  BZ    0DB2
00DA4:  MOVF   x70,W
00DA6:  SUBWF  x65,W
00DA8:  BNC   0DBA
00DAA:  BNZ   0DB2
00DAC:  MOVF   x64,W
00DAE:  SUBWF  x6F,W
00DB0:  BC    0DBA
....................             cmd.autocompletedLen = (uint16_t) len;
00DB2:  MOVFF  570,565
00DB6:  MOVFF  56F,564
.................... 
....................         ++cmd.candidateCount;
00DBA:  INCF   x66,F
00DBC:  BTFSC  4D8.2
00DBE:  INCF   x67,F
.................... 
....................         if (cmd.candidateCount == 1) {
00DC0:  DECFSZ x66,W
00DC2:  BRA    0DD2
00DC4:  MOVF   x67,F
00DC6:  BNZ   0DD2
....................             cmd.firstCandidate = name;
00DC8:  MOVFF  56E,563
00DCC:  MOVFF  56D,562
....................             continue;
00DD0:  BRA    0E2A
....................         }
.................... 
....................         for (size_t j = impl->cmdSize; j < cmd.autocompletedLen; ++j) {
00DD2:  MOVLW  14
00DD4:  ADDWF  x6A,W
00DD6:  MOVWF  4E9
00DD8:  MOVLW  00
00DDA:  ADDWFC x6B,W
00DDC:  MOVWF  4EA
00DDE:  MOVFF  4EC,575
00DE2:  MOVF   4ED,F
00DE4:  MOVFF  4EF,574
00DE8:  MOVF   x75,W
00DEA:  SUBWF  x65,W
00DEC:  BNC   0E2A
00DEE:  BNZ   0DF6
00DF0:  MOVF   x64,W
00DF2:  SUBWF  x74,W
00DF4:  BC    0E2A
....................             if (cmd.firstCandidate[j] != name[j]) {
00DF6:  MOVF   x62,W
00DF8:  ADDWF  x74,W
00DFA:  MOVWF  4E9
00DFC:  MOVF   x63,W
00DFE:  ADDWFC x75,W
00E00:  MOVWF  4EA
00E02:  MOVFF  4EF,576
00E06:  MOVF   x6D,W
00E08:  ADDWF  x74,W
00E0A:  MOVWF  4E9
00E0C:  MOVF   x6E,W
00E0E:  ADDWFC x75,W
00E10:  MOVWF  4EA
00E12:  MOVF   4EF,W
00E14:  SUBWF  x76,W
00E16:  BZ    0E22
....................                 cmd.autocompletedLen = (uint16_t) j;
00E18:  MOVFF  575,565
00E1C:  MOVFF  574,564
....................                 break;
00E20:  BRA    0E2A
....................             }
00E22:  INCF   x74,F
00E24:  BTFSC  4D8.2
00E26:  INCF   x75,F
00E28:  BRA    0DE8
....................         }
00E2A:  INCF   x6C,F
00E2C:  BRA    0C74
....................     }
.................... 
....................     return cmd;
00E2E:  MOVLW  62
00E30:  MOVWF  501
00E32:  MOVLW  05
00E34:  MOVWF  502
00E36:  MOVLB  0
00E38:  RETURN 0
.................... }
.................... 
.................... static void printLiveAutocompletion(EmbeddedCli *cli) {
00E3A:  MOVLW  0A
00E3C:  ADDWF  548,W
00E3E:  MOVWF  4E9
00E40:  MOVLW  00
00E42:  ADDWFC 549,W
00E44:  MOVWF  4EA
00E46:  MOVFF  4EC,54B
00E4A:  MOVF   4ED,F
00E4C:  MOVFF  4EF,54A
....................     PREPARE_IMPL(cli);
.................... 
....................     if (!IS_FLAG_SET(impl->flags, CLI_FLAG_AUTOCOMPLETE_ENABLED))
00E50:  MOVLW  23
00E52:  ADDWF  54A,W
00E54:  MOVWF  4E9
00E56:  MOVLW  00
00E58:  ADDWFC 54B,W
00E5A:  MOVWF  4EA
00E5C:  MOVF   4EF,W
00E5E:  ANDLW  20
00E60:  BNZ   0E64
....................         return;
00E62:  BRA    0FEC
.................... 
....................     AutocompletedCommand cmd = getAutocompletedCommand(cli, impl->cmdBuffer);
00E64:  MOVLW  12
00E66:  ADDWF  54A,W
00E68:  MOVWF  4E9
00E6A:  MOVLW  00
00E6C:  ADDWFC 54B,W
00E6E:  MOVWF  4EA
00E70:  MOVFF  4EC,561
00E74:  MOVF   4ED,F
00E76:  MOVFF  4EF,560
00E7A:  MOVFF  549,55F
00E7E:  MOVFF  548,55E
00E82:  RCALL  0C08
00E84:  MOVFF  502,503
00E88:  MOVFF  501,4E1
00E8C:  MOVFF  502,4E2
00E90:  MOVLW  05
00E92:  MOVWF  4EA
00E94:  MOVLW  4C
00E96:  MOVWF  4E9
00E98:  MOVLW  06
00E9A:  MOVWF  501
00E9C:  MOVFF  4E6,4EE
00EA0:  DECFSZ 501,F
00EA2:  BRA    0E9C
.................... 
....................     if (cmd.candidateCount == 0) {
00EA4:  MOVF   550,F
00EA6:  BNZ   0EC2
00EA8:  MOVF   551,F
00EAA:  BNZ   0EC2
....................         cmd.autocompletedLen = impl->cmdSize;
00EAC:  MOVLW  14
00EAE:  ADDWF  54A,W
00EB0:  MOVWF  4E9
00EB2:  MOVLW  00
00EB4:  ADDWFC 54B,W
00EB6:  MOVWF  4EA
00EB8:  MOVFF  4EC,54F
00EBC:  MOVF   4ED,F
00EBE:  MOVFF  4EF,54E
....................     }
.................... 
....................     // print live autocompletion (or nothing, if it doesn't exist)
....................     for (size_t i = impl->cmdSize; i < cmd.autocompletedLen; ++i) {
00EC2:  MOVLW  14
00EC4:  ADDWF  54A,W
00EC6:  MOVWF  4E9
00EC8:  MOVLW  00
00ECA:  ADDWFC 54B,W
00ECC:  MOVWF  4EA
00ECE:  MOVFF  4EC,553
00ED2:  MOVF   4ED,F
00ED4:  MOVFF  4EF,552
00ED8:  MOVF   553,W
00EDA:  SUBWF  54F,W
00EDC:  BNC   0F1E
00EDE:  BNZ   0EE6
00EE0:  MOVF   54E,W
00EE2:  SUBWF  552,W
00EE4:  BC    0F1E
....................         cli->writeChar(cli, cmd.firstCandidate[i]);
00EE6:  MOVFF  548,500
00EEA:  MOVF   549,W
00EEC:  MOVWF  501
00EEE:  CLRF   502
00EF0:  MOVWF  556
00EF2:  CLRF   557
00EF4:  MOVF   54C,W
00EF6:  ADDWF  552,W
00EF8:  MOVWF  4E9
00EFA:  MOVF   54D,W
00EFC:  ADDWFC 553,W
00EFE:  MOVWF  4EA
00F00:  MOVFF  4EF,527
00F04:  CLRF   4EA
00F06:  MOVFF  556,4E9
00F0A:  MOVFF  549,526
00F0E:  MOVFF  548,525
00F12:  CALL   0004
00F16:  INCF   552,F
00F18:  BTFSC  4D8.2
00F1A:  INCF   553,F
00F1C:  BRA    0ED8
....................     }
....................     // replace with spaces previous autocompletion
....................     for (size_t i = cmd.autocompletedLen; i < impl->inputLineLength; ++i) {
00F1E:  MOVFF  54F,555
00F22:  MOVFF  54E,554
00F26:  MOVLW  20
00F28:  ADDWF  54A,W
00F2A:  MOVWF  4E9
00F2C:  MOVLW  00
00F2E:  ADDWFC 54B,W
00F30:  MOVWF  4EA
00F32:  MOVFF  4EC,503
00F36:  MOVF   4ED,F
00F38:  MOVFF  4EF,501
00F3C:  MOVF   555,W
00F3E:  SUBWF  503,W
00F40:  BNC   0F74
00F42:  BNZ   0F4A
00F44:  MOVF   501,W
00F46:  SUBWF  554,W
00F48:  BC    0F74
....................         cli->writeChar(cli, ' ');
00F4A:  MOVFF  548,500
00F4E:  MOVF   549,W
00F50:  MOVWF  501
00F52:  CLRF   502
00F54:  MOVWF  556
00F56:  CLRF   557
00F58:  CLRF   4EA
00F5A:  MOVWF  4E9
00F5C:  MOVFF  549,526
00F60:  MOVFF  548,525
00F64:  MOVLW  20
00F66:  MOVWF  527
00F68:  CALL   0004
00F6C:  INCF   554,F
00F6E:  BTFSC  4D8.2
00F70:  INCF   555,F
00F72:  BRA    0F26
....................     }
....................     impl->inputLineLength = cmd.autocompletedLen;
00F74:  MOVLW  20
00F76:  ADDWF  54A,W
00F78:  MOVWF  4E9
00F7A:  MOVLW  00
00F7C:  ADDWFC 54B,W
00F7E:  MOVWF  4EA
00F80:  MOVFF  54F,4EC
00F84:  MOVF   4ED,F
00F86:  MOVFF  54E,4EF
....................     cli->writeChar(cli, '\r');
00F8A:  MOVFF  548,500
00F8E:  MOVF   549,W
00F90:  MOVWF  501
00F92:  CLRF   502
00F94:  MOVWF  556
00F96:  CLRF   557
00F98:  CLRF   4EA
00F9A:  MOVWF  4E9
00F9C:  MOVFF  549,526
00FA0:  MOVFF  548,525
00FA4:  MOVLW  0D
00FA6:  MOVWF  527
00FA8:  CALL   0004
....................     // print current command again so cursor is moved to initial place
....................     writeToOutput(cli, impl->invitation);
00FAC:  MOVFF  54A,4E9
00FB0:  MOVFF  54B,4EA
00FB4:  MOVFF  4EC,615
00FB8:  MOVF   4ED,F
00FBA:  MOVFF  4EF,614
00FBE:  MOVFF  549,613
00FC2:  MOVFF  548,612
00FC6:  CALL   07A2
....................     writeToOutput(cli, impl->cmdBuffer);
00FCA:  MOVLW  12
00FCC:  ADDWF  54A,W
00FCE:  MOVWF  4E9
00FD0:  MOVLW  00
00FD2:  ADDWFC 54B,W
00FD4:  MOVWF  4EA
00FD6:  MOVFF  4EC,615
00FDA:  MOVF   4ED,F
00FDC:  MOVFF  4EF,614
00FE0:  MOVFF  549,613
00FE4:  MOVFF  548,612
00FE8:  CALL   07A2
00FEC:  RETURN 0
.................... }
.................... 
.................... static void onAutocompleteRequest(EmbeddedCli *cli) {
*
0129E:  MOVLW  0A
012A0:  ADDWF  53E,W
012A2:  MOVWF  4E9
012A4:  MOVLW  00
012A6:  ADDWFC 53F,W
012A8:  MOVWF  4EA
012AA:  MOVFF  4EC,541
012AE:  MOVF   4ED,F
012B0:  MOVFF  4EF,540
012B4:  MOVLW  12
012B6:  ADDWF  540,W
012B8:  MOVWF  4E9
012BA:  MOVLW  00
012BC:  ADDWFC 541,W
012BE:  MOVWF  4EA
012C0:  MOVFF  4EC,561
012C4:  MOVF   4ED,F
012C6:  MOVFF  4EF,560
012CA:  MOVFF  53F,55F
012CE:  MOVFF  53E,55E
012D2:  RCALL  0C08
012D4:  MOVFF  502,503
012D8:  MOVFF  501,4E1
012DC:  MOVFF  502,4E2
012E0:  MOVLW  05
012E2:  MOVWF  4EA
012E4:  MOVLW  42
012E6:  MOVWF  4E9
012E8:  MOVLW  06
012EA:  MOVWF  501
012EC:  MOVFF  4E6,4EE
012F0:  DECFSZ 501,F
012F2:  BRA    12EC
....................     PREPARE_IMPL(cli);
.................... 
....................     AutocompletedCommand cmd = getAutocompletedCommand(cli, impl->cmdBuffer);
.................... 
....................     if (cmd.candidateCount == 0)
012F4:  MOVF   546,F
012F6:  BNZ   12FE
012F8:  MOVF   547,F
012FA:  BNZ   12FE
....................         return;
012FC:  BRA    15A4
.................... 
....................     if (cmd.candidateCount == 1 || cmd.autocompletedLen > impl->cmdSize) {
012FE:  DECFSZ 546,W
01300:  BRA    1306
01302:  MOVF   547,F
01304:  BZ    132E
01306:  MOVLW  14
01308:  ADDWF  540,W
0130A:  MOVWF  4E9
0130C:  MOVLW  00
0130E:  ADDWFC 541,W
01310:  MOVWF  4EA
01312:  MOVFF  4EC,503
01316:  MOVF   4ED,F
01318:  MOVFF  4EF,501
0131C:  MOVF   503,W
0131E:  SUBWF  545,W
01320:  BTFSS  4D8.0
01322:  BRA    146C
01324:  BNZ   132E
01326:  MOVF   544,W
01328:  SUBWF  501,W
0132A:  BTFSC  4D8.0
0132C:  BRA    146C
....................         // can copy from index cmdSize, but prefix is the same, so copy everything
....................         memcpy(impl->cmdBuffer, cmd.firstCandidate, cmd.autocompletedLen);
0132E:  MOVLW  12
01330:  ADDWF  540,W
01332:  MOVWF  4E9
01334:  MOVLW  00
01336:  ADDWFC 541,W
01338:  MOVWF  4EA
0133A:  MOVFF  4EC,54C
0133E:  MOVF   4ED,F
01340:  MOVFF  4EF,54B
01344:  MOVFF  54C,4EA
01348:  MOVFF  54B,4E9
0134C:  MOVFF  543,4E2
01350:  MOVFF  542,4E1
01354:  MOVFF  545,502
01358:  MOVFF  544,501
0135C:  MOVF   501,F
0135E:  BZ    1364
01360:  INCF   502,F
01362:  BRA    1368
01364:  MOVF   502,F
01366:  BZ    1374
01368:  MOVFF  4E6,4EE
0136C:  DECFSZ 501,F
0136E:  BRA    1368
01370:  DECFSZ 502,F
01372:  BRA    1368
....................         if (cmd.candidateCount == 1) {
01374:  DECFSZ 546,W
01376:  BRA    13A8
01378:  MOVF   547,F
0137A:  BNZ   13A8
....................             impl->cmdBuffer[cmd.autocompletedLen] = ' ';
0137C:  MOVLW  12
0137E:  ADDWF  540,W
01380:  MOVWF  4E9
01382:  MOVLW  00
01384:  ADDWFC 541,W
01386:  MOVWF  4EA
01388:  MOVFF  4EC,54C
0138C:  MOVF   4ED,F
0138E:  MOVFF  4EF,54B
01392:  MOVF   54B,W
01394:  ADDWF  544,W
01396:  MOVWF  4E9
01398:  MOVF   54C,W
0139A:  ADDWFC 545,W
0139C:  MOVWF  4EA
0139E:  MOVLW  20
013A0:  MOVWF  4EF
....................             ++cmd.autocompletedLen;
013A2:  INCF   544,F
013A4:  BTFSC  4D8.2
013A6:  INCF   545,F
....................         }
....................         impl->cmdBuffer[cmd.autocompletedLen] = '\0';
013A8:  MOVLW  12
013AA:  ADDWF  540,W
013AC:  MOVWF  4E9
013AE:  MOVLW  00
013B0:  ADDWFC 541,W
013B2:  MOVWF  4EA
013B4:  MOVFF  4EC,54C
013B8:  MOVF   4ED,F
013BA:  MOVFF  4EF,54B
013BE:  MOVF   54B,W
013C0:  ADDWF  544,W
013C2:  MOVWF  4E9
013C4:  MOVF   54C,W
013C6:  ADDWFC 545,W
013C8:  MOVWF  4EA
013CA:  CLRF   4EF
.................... 
....................         writeToOutput(cli, &impl->cmdBuffer[impl->cmdSize]);
013CC:  MOVLW  12
013CE:  ADDWF  540,W
013D0:  MOVWF  4E9
013D2:  MOVLW  00
013D4:  ADDWFC 541,W
013D6:  MOVWF  4EA
013D8:  MOVFF  4EC,54C
013DC:  MOVF   4ED,F
013DE:  MOVFF  4EF,54B
013E2:  MOVLW  14
013E4:  ADDWF  540,W
013E6:  MOVWF  4E9
013E8:  MOVLW  00
013EA:  ADDWFC 541,W
013EC:  MOVWF  4EA
013EE:  MOVFF  4EC,54E
013F2:  MOVF   4ED,F
013F4:  MOVFF  4EF,54D
013F8:  MOVF   54B,W
013FA:  ADDWF  54D,W
013FC:  MOVWF  501
013FE:  MOVF   54C,W
01400:  ADDWFC 54E,W
01402:  MOVWF  503
01404:  MOVFF  501,54F
01408:  MOVWF  550
0140A:  MOVFF  53F,613
0140E:  MOVFF  53E,612
01412:  MOVFF  4E8,615
01416:  MOVFF  501,614
0141A:  CALL   07A2
....................         impl->cmdSize = cmd.autocompletedLen;
0141E:  MOVLW  14
01420:  ADDWF  540,W
01422:  MOVWF  4E9
01424:  MOVLW  00
01426:  ADDWFC 541,W
01428:  MOVWF  4EA
0142A:  MOVFF  545,4EC
0142E:  MOVF   4ED,F
01430:  MOVFF  544,4EF
....................         impl->inputLineLength = impl->cmdSize;
01434:  MOVLW  20
01436:  ADDWF  540,W
01438:  MOVWF  501
0143A:  MOVLW  00
0143C:  ADDWFC 541,W
0143E:  MOVWF  503
01440:  MOVWF  54C
01442:  MOVLW  14
01444:  ADDWF  540,W
01446:  MOVWF  4E9
01448:  MOVLW  00
0144A:  ADDWFC 541,W
0144C:  MOVWF  4EA
0144E:  MOVFF  4EC,503
01452:  MOVF   4ED,F
01454:  MOVFF  4EF,54D
01458:  MOVFF  54C,4EA
0145C:  MOVFF  501,4E9
01460:  MOVFF  503,4EC
01464:  MOVF   4ED,F
01466:  MOVFF  54D,4EF
....................         return;
0146A:  BRA    15A4
....................     }
.................... 
....................     // with multiple candidates when we already completed to common prefix
....................     // we show all candidates and print input again
....................     // we need to completely clear current line since it begins with invitation
....................     clearCurrentLine(cli);
0146C:  MOVFF  53F,54C
01470:  MOVFF  53E,54B
01474:  CALL   09F6
.................... 
....................     for (int i = 0; i < impl->bindingsCount; ++i) {
01478:  CLRF   548
0147A:  MOVLW  1C
0147C:  ADDWF  540,W
0147E:  MOVWF  4E9
01480:  MOVLW  00
01482:  ADDWFC 541,W
01484:  MOVWF  4EA
01486:  MOVFF  4EC,503
0148A:  MOVF   4ED,F
0148C:  MOVFF  4EF,501
01490:  MOVF   503,F
01492:  BNZ   149A
01494:  MOVF   501,W
01496:  SUBWF  548,W
01498:  BC    152E
....................         // autocomplete flag is set for all candidates by last call to
....................         // getAutocompletedCommand
....................         if (!(impl->bindingsFlags[i] & BINDING_FLAG_AUTOCOMPLETE))
0149A:  MOVLW  1A
0149C:  ADDWF  540,W
0149E:  MOVWF  4E9
014A0:  MOVLW  00
014A2:  ADDWFC 541,W
014A4:  MOVWF  4EA
014A6:  MOVFF  4EC,54C
014AA:  MOVF   4ED,F
014AC:  MOVFF  4EF,54B
014B0:  MOVF   548,W
014B2:  ADDWF  54B,W
014B4:  MOVWF  4E9
014B6:  MOVLW  00
014B8:  ADDWFC 54C,W
014BA:  MOVWF  4EA
014BC:  BTFSC  4EF.0
014BE:  BRA    14C2
....................             continue;
014C0:  BRA    152A
.................... 
....................         char *name = impl->bindings[i].name;
014C2:  MOVLW  18
014C4:  ADDWF  540,W
014C6:  MOVWF  4E9
014C8:  MOVLW  00
014CA:  ADDWFC 541,W
014CC:  MOVWF  4EA
014CE:  MOVFF  4EC,54C
014D2:  MOVF   4ED,F
014D4:  MOVFF  4EF,54B
014D8:  MOVLB  5
014DA:  CLRF   xCD
014DC:  MOVFF  548,5CC
014E0:  CLRF   xCF
014E2:  MOVLW  0B
014E4:  MOVWF  xCE
014E6:  MOVLB  0
014E8:  CALL   004A
014EC:  MOVF   54B,W
014EE:  ADDWF  501,W
014F0:  MOVWF  4E9
014F2:  MOVF   54C,W
014F4:  ADDWFC 502,W
014F6:  MOVWF  4EA
014F8:  MOVFF  4EC,54A
014FC:  MOVF   4ED,F
014FE:  MOVFF  4EF,549
.................... 
....................         writeToOutput(cli, name);
01502:  MOVFF  53F,613
01506:  MOVFF  53E,612
0150A:  MOVFF  54A,615
0150E:  MOVFF  549,614
01512:  CALL   07A2
....................         writeToOutput(cli, lineBreak);
01516:  MOVFF  53F,613
0151A:  MOVFF  53E,612
0151E:  MOVFF  51C,615
01522:  MOVFF  51B,614
01526:  CALL   07A2
0152A:  INCF   548,F
0152C:  BRA    147A
....................     }
.................... 
....................     writeToOutput(cli, impl->invitation);
0152E:  MOVFF  540,4E9
01532:  MOVFF  541,4EA
01536:  MOVFF  4EC,615
0153A:  MOVF   4ED,F
0153C:  MOVFF  4EF,614
01540:  MOVFF  53F,613
01544:  MOVFF  53E,612
01548:  CALL   07A2
....................     writeToOutput(cli, impl->cmdBuffer);
0154C:  MOVLW  12
0154E:  ADDWF  540,W
01550:  MOVWF  4E9
01552:  MOVLW  00
01554:  ADDWFC 541,W
01556:  MOVWF  4EA
01558:  MOVFF  4EC,615
0155C:  MOVF   4ED,F
0155E:  MOVFF  4EF,614
01562:  MOVFF  53F,613
01566:  MOVFF  53E,612
0156A:  CALL   07A2
.................... 
....................     impl->inputLineLength = impl->cmdSize;
0156E:  MOVLW  20
01570:  ADDWF  540,W
01572:  MOVWF  501
01574:  MOVLW  00
01576:  ADDWFC 541,W
01578:  MOVWF  503
0157A:  MOVWF  54C
0157C:  MOVLW  14
0157E:  ADDWF  540,W
01580:  MOVWF  4E9
01582:  MOVLW  00
01584:  ADDWFC 541,W
01586:  MOVWF  4EA
01588:  MOVFF  4EC,503
0158C:  MOVF   4ED,F
0158E:  MOVFF  4EF,54D
01592:  MOVFF  54C,4EA
01596:  MOVFF  501,4E9
0159A:  MOVFF  503,4EC
0159E:  MOVF   4ED,F
015A0:  MOVFF  54D,4EF
015A4:  RETURN 0
.................... }
.................... 
.................... static void clearCurrentLine(EmbeddedCli *cli) {
*
009F6:  MOVLW  0A
009F8:  ADDWF  54B,W
009FA:  MOVWF  4E9
009FC:  MOVLW  00
009FE:  ADDWFC 54C,W
00A00:  MOVWF  4EA
00A02:  MOVFF  4EC,54E
00A06:  MOVF   4ED,F
00A08:  MOVFF  4EF,54D
00A0C:  MOVLW  20
00A0E:  ADDWF  54D,W
00A10:  MOVWF  4E9
00A12:  MOVLW  00
00A14:  ADDWFC 54E,W
00A16:  MOVWF  4EA
00A18:  MOVFF  4EC,554
00A1C:  MOVF   4ED,F
00A1E:  MOVFF  4EF,553
00A22:  MOVFF  54D,4E9
00A26:  MOVFF  54E,4EA
00A2A:  MOVFF  4EC,61B
00A2E:  MOVF   4ED,F
00A30:  MOVFF  4EF,61A
00A34:  RCALL  0768
00A36:  MOVF   501,W
00A38:  ADDWF  553,W
00A3A:  MOVWF  54F
00A3C:  MOVF   502,W
00A3E:  ADDWFC 554,W
00A40:  MOVWF  550
....................     PREPARE_IMPL(cli);
....................     size_t len = impl->inputLineLength + strlen(impl->invitation);
.................... 
....................     cli->writeChar(cli, '\r');
00A42:  MOVFF  54B,500
00A46:  MOVF   54C,W
00A48:  MOVWF  501
00A4A:  CLRF   502
00A4C:  MOVWF  553
00A4E:  CLRF   554
00A50:  CLRF   4EA
00A52:  MOVWF  4E9
00A54:  MOVFF  54C,526
00A58:  MOVFF  54B,525
00A5C:  MOVLW  0D
00A5E:  MOVWF  527
00A60:  CALL   0004
....................     for (size_t i = 0; i < len; ++i) {
00A64:  CLRF   552
00A66:  CLRF   551
00A68:  MOVF   552,W
00A6A:  SUBWF  550,W
00A6C:  BNC   0AA0
00A6E:  BNZ   0A76
00A70:  MOVF   54F,W
00A72:  SUBWF  551,W
00A74:  BC    0AA0
....................         cli->writeChar(cli, ' ');
00A76:  MOVFF  54B,500
00A7A:  MOVF   54C,W
00A7C:  MOVWF  501
00A7E:  CLRF   502
00A80:  MOVWF  553
00A82:  CLRF   554
00A84:  CLRF   4EA
00A86:  MOVWF  4E9
00A88:  MOVFF  54C,526
00A8C:  MOVFF  54B,525
00A90:  MOVLW  20
00A92:  MOVWF  527
00A94:  CALL   0004
00A98:  INCF   551,F
00A9A:  BTFSC  4D8.2
00A9C:  INCF   552,F
00A9E:  BRA    0A68
....................     }
....................     cli->writeChar(cli, '\r');
00AA0:  MOVFF  54B,500
00AA4:  MOVF   54C,W
00AA6:  MOVWF  501
00AA8:  CLRF   502
00AAA:  MOVWF  553
00AAC:  CLRF   554
00AAE:  CLRF   4EA
00AB0:  MOVWF  4E9
00AB2:  MOVFF  54C,526
00AB6:  MOVFF  54B,525
00ABA:  MOVLW  0D
00ABC:  MOVWF  527
00ABE:  CALL   0004
....................     impl->inputLineLength = 0;
00AC2:  MOVLW  20
00AC4:  ADDWF  54D,W
00AC6:  MOVWF  4E9
00AC8:  MOVLW  00
00ACA:  ADDWFC 54E,W
00ACC:  MOVWF  4EA
00ACE:  CLRF   4EC
00AD0:  MOVF   4ED,F
00AD2:  CLRF   4EF
00AD4:  RETURN 0
.................... }
.................... 
.................... static void writeToOutput(EmbeddedCli *cli, char *str) {
*
007A2:  MOVFF  615,61B
007A6:  MOVFF  614,61A
007AA:  RCALL  0768
007AC:  MOVFF  502,617
007B0:  MOVFF  501,616
....................     size_t len = strlen(str);
.................... 
....................     for (size_t i = 0; i < len; ++i) {
007B4:  MOVLB  6
007B6:  CLRF   x19
007B8:  CLRF   x18
007BA:  MOVF   x19,W
007BC:  SUBWF  x17,W
007BE:  BNC   0802
007C0:  BNZ   07C8
007C2:  MOVF   x16,W
007C4:  SUBWF  x18,W
007C6:  BC    0802
....................         cli->writeChar(cli, str[i]);
007C8:  MOVFF  612,500
007CC:  MOVF   x13,W
007CE:  MOVWF  501
007D0:  CLRF   502
007D2:  MOVWF  x1A
007D4:  CLRF   x1B
007D6:  MOVF   x14,W
007D8:  ADDWF  x18,W
007DA:  MOVWF  4E9
007DC:  MOVF   x15,W
007DE:  ADDWFC x19,W
007E0:  MOVWF  4EA
007E2:  MOVFF  4EF,527
007E6:  CLRF   4EA
007E8:  MOVFF  61A,4E9
007EC:  MOVFF  613,526
007F0:  MOVFF  612,525
007F4:  MOVLB  0
007F6:  RCALL  0004
007F8:  MOVLB  6
007FA:  INCF   x18,F
007FC:  BTFSC  4D8.2
007FE:  INCF   x19,F
00800:  BRA    07BA
....................     }
00802:  MOVLB  0
00804:  RETURN 0
.................... }
.................... 
.................... static bool isControlChar(char c) {
....................     return c == '\r' || c == '\n' || c == '\b' || c == '\t' || c == 0x7F;
*
01274:  MOVF   539,W
01276:  SUBLW  0D
01278:  BZ    1296
0127A:  MOVF   539,W
0127C:  SUBLW  0A
0127E:  BZ    1296
01280:  MOVF   539,W
01282:  SUBLW  08
01284:  BZ    1296
01286:  MOVF   539,W
01288:  SUBLW  09
0128A:  BZ    1296
0128C:  MOVF   539,W
0128E:  SUBLW  7F
01290:  BZ    1296
01292:  MOVLW  00
01294:  BRA    1298
01296:  MOVLW  01
01298:  MOVWF  501
0129A:  GOTO   2CCC (RETURN)
.................... }
.................... 
.................... static bool isDisplayableChar(char c) {
....................     return (c >= 32 && c <= 126);
*
02A8E:  MOVF   539,W
02A90:  SUBLW  1F
02A92:  BC    2A9A
02A94:  MOVF   539,W
02A96:  SUBLW  7E
02A98:  BC    2A9E
02A9A:  MOVLW  00
02A9C:  BRA    2AA0
02A9E:  MOVLW  01
02AA0:  MOVWF  501
02AA2:  GOTO   2CE6 (RETURN)
.................... }
.................... 
.................... static uint16_t fifoBufAvailable(FifoBuf *buffer) {
....................     if (buffer->back >= buffer->front)
*
00806:  MOVLW  04
00808:  ADDWF  53B,W
0080A:  MOVWF  4E9
0080C:  MOVLW  00
0080E:  ADDWFC 53C,W
00810:  MOVWF  4EA
00812:  MOVFF  4EC,53E
00816:  MOVF   4ED,F
00818:  MOVFF  4EF,53D
0081C:  MOVLW  02
0081E:  ADDWF  53B,W
00820:  MOVWF  4E9
00822:  MOVLW  00
00824:  ADDWFC 53C,W
00826:  MOVWF  4EA
00828:  MOVFF  4EC,503
0082C:  MOVF   4ED,F
0082E:  MOVFF  4EF,501
00832:  MOVF   503,W
00834:  SUBWF  53E,W
00836:  BNC   087E
00838:  BNZ   0840
0083A:  MOVF   501,W
0083C:  SUBWF  53D,W
0083E:  BNC   087E
....................         return (uint16_t) (buffer->back - buffer->front);
00840:  MOVLW  04
00842:  ADDWF  53B,W
00844:  MOVWF  4E9
00846:  MOVLW  00
00848:  ADDWFC 53C,W
0084A:  MOVWF  4EA
0084C:  MOVFF  4EC,53E
00850:  MOVF   4ED,F
00852:  MOVFF  4EF,53D
00856:  MOVLW  02
00858:  ADDWF  53B,W
0085A:  MOVWF  4E9
0085C:  MOVLW  00
0085E:  ADDWFC 53C,W
00860:  MOVWF  4EA
00862:  MOVFF  4EC,503
00866:  MOVF   4ED,F
00868:  MOVF   4EF,W
0086A:  SUBWF  53D,W
0086C:  MOVWF  500
0086E:  MOVF   503,W
00870:  SUBWFB 53E,W
00872:  MOVWF  503
00874:  MOVFF  500,501
00878:  MOVWF  502
0087A:  BRA    08CE
0087C:  BRA    08CE
....................     else
....................         return (uint16_t) (buffer->size - buffer->front + buffer->back);
0087E:  MOVLW  06
00880:  ADDWF  53B,W
00882:  MOVWF  4E9
00884:  MOVLW  00
00886:  ADDWFC 53C,W
00888:  MOVWF  4EA
0088A:  MOVFF  4EC,53E
0088E:  MOVF   4ED,F
00890:  MOVFF  4EF,53D
00894:  MOVLW  02
00896:  ADDWF  53B,W
00898:  MOVWF  4E9
0089A:  MOVLW  00
0089C:  ADDWFC 53C,W
0089E:  MOVWF  4EA
008A0:  MOVFF  4EC,503
008A4:  MOVF   4ED,F
008A6:  MOVF   4EF,W
008A8:  SUBWF  53D,F
008AA:  MOVF   503,W
008AC:  SUBWFB 53E,F
008AE:  MOVLW  04
008B0:  ADDWF  53B,W
008B2:  MOVWF  4E9
008B4:  MOVLW  00
008B6:  ADDWFC 53C,W
008B8:  MOVWF  4EA
008BA:  MOVFF  4EC,503
008BE:  MOVF   4ED,F
008C0:  MOVF   4EF,W
008C2:  ADDWF  53D,W
008C4:  MOVWF  501
008C6:  MOVF   53E,W
008C8:  ADDWFC 503,F
008CA:  MOVFF  503,502
008CE:  GOTO   2C4E (RETURN)
.................... }
.................... 
.................... static char fifoBufPop(FifoBuf *buffer) {
*
00916:  CLRF   53D
....................     char a = '\0';
....................     if (buffer->front != buffer->back) {
00918:  MOVLW  02
0091A:  ADDWF  53B,W
0091C:  MOVWF  4E9
0091E:  MOVLW  00
00920:  ADDWFC 53C,W
00922:  MOVWF  4EA
00924:  MOVFF  4EC,53F
00928:  MOVF   4ED,F
0092A:  MOVFF  4EF,53E
0092E:  MOVLW  04
00930:  ADDWF  53B,W
00932:  MOVWF  4E9
00934:  MOVLW  00
00936:  ADDWFC 53C,W
00938:  MOVWF  4EA
0093A:  MOVFF  4EC,503
0093E:  MOVF   4ED,F
00940:  MOVF   4EF,W
00942:  SUBWF  53E,W
00944:  BNZ   094C
00946:  MOVF   503,W
00948:  SUBWF  53F,W
0094A:  BZ    09EE
....................         a = buffer->buf[buffer->front];
0094C:  MOVFF  53B,4E9
00950:  MOVFF  53C,4EA
00954:  MOVFF  4EC,53F
00958:  MOVF   4ED,F
0095A:  MOVFF  4EF,53E
0095E:  MOVLW  02
00960:  ADDWF  53B,W
00962:  MOVWF  4E9
00964:  MOVLW  00
00966:  ADDWFC 53C,W
00968:  MOVWF  4EA
0096A:  MOVFF  4EC,541
0096E:  MOVF   4ED,F
00970:  MOVFF  4EF,540
00974:  MOVF   53E,W
00976:  ADDWF  540,W
00978:  MOVWF  4E9
0097A:  MOVF   53F,W
0097C:  ADDWFC 541,W
0097E:  MOVWF  4EA
00980:  MOVFF  4EF,53D
....................         buffer->front = (uint16_t) (buffer->front + 1) % buffer->size;
00984:  MOVLW  02
00986:  ADDWF  53B,W
00988:  MOVWF  501
0098A:  MOVLW  00
0098C:  ADDWFC 53C,W
0098E:  MOVWF  503
00990:  MOVFF  501,53E
00994:  MOVWF  53F
00996:  MOVLW  02
00998:  ADDWF  53B,W
0099A:  MOVWF  4E9
0099C:  MOVLW  00
0099E:  ADDWFC 53C,W
009A0:  MOVWF  4EA
009A2:  MOVFF  4EC,541
009A6:  MOVF   4ED,F
009A8:  MOVFF  4EF,540
009AC:  MOVLW  01
009AE:  ADDWF  540,F
009B0:  MOVLW  00
009B2:  ADDWFC 541,F
009B4:  MOVLW  06
009B6:  ADDWF  53B,W
009B8:  MOVWF  4E9
009BA:  MOVLW  00
009BC:  ADDWFC 53C,W
009BE:  MOVWF  4EA
009C0:  MOVFF  4EC,503
009C4:  MOVF   4ED,F
009C6:  MOVFF  4EF,546
009CA:  MOVFF  503,543
009CE:  MOVFF  541,545
009D2:  MOVFF  540,544
009D6:  MOVFF  503,547
009DA:  BRA    08D2
009DC:  MOVFF  53F,4EA
009E0:  MOVFF  53E,4E9
009E4:  MOVFF  503,4EC
009E8:  MOVF   4ED,F
009EA:  MOVFF  500,4EF
....................     }
....................     return a;
009EE:  MOVFF  53D,501
009F2:  GOTO   2C70 (RETURN)
.................... }
.................... 
.................... static bool fifoBufPush(FifoBuf *buffer, char a) {
....................     uint16_t newBack = (uint16_t) (buffer->back + 1) % buffer->size;
....................     if (newBack != buffer->front) {
....................         buffer->buf[buffer->back] = a;
....................         buffer->back = newBack;
....................         return true;
....................     }
....................     return false;
.................... }
.................... 
.................... static bool historyPut(CliHistory *history, char *str) {
*
018E8:  MOVFF  556,61B
018EC:  MOVFF  555,61A
018F0:  CALL   0768
018F4:  MOVFF  502,558
018F8:  MOVFF  501,557
....................     size_t len = strlen(str);
....................     // each item is ended with \0 so, need to have that much space at least
....................     if (history->bufferSize < len + 1)
018FC:  MOVLW  02
018FE:  ADDWF  553,W
01900:  MOVWF  4E9
01902:  MOVLW  00
01904:  ADDWFC 554,W
01906:  MOVWF  4EA
01908:  MOVFF  4EC,562
0190C:  MOVF   4ED,F
0190E:  MOVFF  4EF,561
01912:  MOVLW  01
01914:  ADDWF  557,W
01916:  MOVWF  501
01918:  MOVLW  00
0191A:  ADDWFC 558,W
0191C:  MOVWF  503
0191E:  MOVF   501,W
01920:  MOVLB  5
01922:  MOVF   x62,W
01924:  SUBWF  503,W
01926:  BNC   1936
01928:  BNZ   1930
0192A:  MOVF   501,W
0192C:  SUBWF  x61,W
0192E:  BC    1936
....................         return false;
01930:  MOVLW  00
01932:  MOVWF  501
01934:  BRA    1B10
.................... 
....................     // remove str from history (if it's present) so we don't get duplicates
....................     historyRemove(history, str);
01936:  MOVFF  554,562
0193A:  MOVFF  553,561
0193E:  MOVFF  556,564
01942:  MOVFF  555,563
01946:  MOVLB  0
01948:  BRA    1744
.................... 
....................     size_t usedSize;
....................     // remove old items if new one can't fit into buffer
....................     while (history->itemsCount > 0) {
0194A:  MOVLW  06
0194C:  ADDWF  553,W
0194E:  MOVWF  4E9
01950:  MOVLW  00
01952:  ADDWFC 554,W
01954:  MOVWF  4EA
01956:  MOVFF  4EC,562
0195A:  MOVF   4ED,F
0195C:  MOVFF  4EF,561
01960:  MOVLB  5
01962:  MOVF   x61,F
01964:  BNZ   196A
01966:  MOVF   x62,F
01968:  BZ    1A38
....................         char *item = historyGet(history, history->itemsCount);
....................         size_t itemLen = strlen(item);
0196A:  MOVLW  06
0196C:  ADDWF  553,W
0196E:  MOVWF  4E9
01970:  MOVLW  00
01972:  ADDWFC 554,W
01974:  MOVWF  4EA
01976:  MOVFF  4EC,566
0197A:  MOVF   4ED,F
0197C:  MOVFF  4EF,565
01980:  MOVFF  554,564
01984:  MOVFF  553,563
01988:  MOVLB  0
0198A:  CALL   0BAC
0198E:  MOVFF  502,55C
01992:  MOVFF  501,55B
01996:  MOVFF  55C,61B
0199A:  MOVFF  55B,61A
0199E:  CALL   0768
019A2:  MOVFF  502,55E
019A6:  MOVFF  501,55D
....................         usedSize = ((size_t) (item - history->buf)) + itemLen + 1;
019AA:  MOVFF  553,4E9
019AE:  MOVFF  554,4EA
019B2:  MOVFF  4EC,503
019B6:  MOVF   4ED,F
019B8:  MOVF   4EF,W
019BA:  SUBWF  55B,W
019BC:  MOVWF  500
019BE:  MOVF   503,W
019C0:  SUBWFB 55C,W
019C2:  MOVFF  500,561
019C6:  MOVLB  5
019C8:  MOVWF  x62
019CA:  MOVF   55D,W
019CC:  ADDWF  x61,F
019CE:  MOVF   55E,W
019D0:  ADDWFC x62,F
019D2:  MOVLW  01
019D4:  ADDWF  x61,W
019D6:  MOVWF  559
019D8:  MOVLW  00
019DA:  ADDWFC x62,W
019DC:  MOVWF  55A
.................... 
....................         size_t freeSpace = history->bufferSize - usedSize;
019DE:  MOVLW  02
019E0:  ADDWF  553,W
019E2:  MOVWF  4E9
019E4:  MOVLW  00
019E6:  ADDWFC 554,W
019E8:  MOVWF  4EA
019EA:  MOVFF  4EC,562
019EE:  MOVF   4ED,F
019F0:  MOVFF  4EF,561
019F4:  MOVF   559,W
019F6:  SUBWF  x61,W
019F8:  MOVWF  45F
019FA:  MOVF   55A,W
019FC:  SUBWFB x62,W
019FE:  MOVWF  x60
.................... 
....................         if (freeSpace >= len + 1)
01A00:  MOVLW  01
01A02:  ADDWF  557,W
01A04:  MOVWF  501
01A06:  MOVLW  00
01A08:  ADDWFC 558,W
01A0A:  MOVWF  503
01A0C:  MOVF   503,W
01A0E:  SUBWF  x60,W
01A10:  BNC   1A1C
01A12:  BNZ   1A1A
01A14:  MOVF   501,W
01A16:  SUBWF  45F,W
01A18:  BNC   1A1C
....................             break;
01A1A:  BRA    1A38
.................... 
....................         // space not enough, remove last element
....................         --history->itemsCount;
01A1C:  MOVLW  06
01A1E:  ADDWF  553,W
01A20:  MOVWF  4E9
01A22:  MOVLW  00
01A24:  ADDWFC 554,W
01A26:  MOVWF  4EA
01A28:  MOVLW  FF
01A2A:  ADDWF  4EF,F
01A2C:  BC    1A32
01A2E:  MOVF   4EE,F
01A30:  DECF   4ED,F
01A32:  MOVLB  0
01A34:  BRA    194A
01A36:  MOVLB  5
....................     }
....................     if (history->itemsCount > 0) {
01A38:  MOVLW  06
01A3A:  ADDWF  553,W
01A3C:  MOVWF  4E9
01A3E:  MOVLW  00
01A40:  ADDWFC 554,W
01A42:  MOVWF  4EA
01A44:  MOVFF  4EC,562
01A48:  MOVF   4ED,F
01A4A:  MOVFF  4EF,561
01A4E:  MOVF   x61,F
01A50:  BNZ   1A56
01A52:  MOVF   x62,F
01A54:  BZ    1AAC
....................         // when history not empty, shift elements so new item is first
....................         memmove(&history->buf[len + 1], history->buf, usedSize);
01A56:  MOVFF  553,4E9
01A5A:  MOVFF  554,4EA
01A5E:  MOVFF  4EC,562
01A62:  MOVF   4ED,F
01A64:  MOVFF  4EF,561
01A68:  MOVLW  01
01A6A:  ADDWF  557,W
01A6C:  MOVWF  x63
01A6E:  MOVLW  00
01A70:  ADDWFC 558,W
01A72:  MOVWF  x64
01A74:  MOVF   x61,W
01A76:  ADDWF  x63,W
01A78:  MOVWF  501
01A7A:  MOVF   x62,W
01A7C:  ADDWFC x64,W
01A7E:  MOVWF  503
01A80:  MOVFF  501,565
01A84:  MOVWF  x66
01A86:  MOVFF  553,4E9
01A8A:  MOVFF  554,4EA
01A8E:  MOVFF  4EC,574
01A92:  MOVF   4ED,F
01A94:  MOVFF  4EF,573
01A98:  MOVWF  x72
01A9A:  MOVFF  501,571
01A9E:  MOVFF  55A,576
01AA2:  MOVFF  559,575
01AA6:  MOVLB  0
01AA8:  RCALL  1664
01AAA:  MOVLB  5
....................     }
....................     memcpy(history->buf, str, len + 1);
01AAC:  MOVFF  553,4E9
01AB0:  MOVFF  554,4EA
01AB4:  MOVFF  4EC,562
01AB8:  MOVF   4ED,F
01ABA:  MOVFF  4EF,561
01ABE:  MOVLW  01
01AC0:  ADDWF  557,W
01AC2:  MOVWF  x63
01AC4:  MOVLW  00
01AC6:  ADDWFC 558,W
01AC8:  MOVWF  x64
01ACA:  MOVFF  562,4EA
01ACE:  MOVFF  561,4E9
01AD2:  MOVFF  556,4E2
01AD6:  MOVFF  555,4E1
01ADA:  MOVWF  502
01ADC:  MOVFF  563,501
01AE0:  MOVF   501,F
01AE2:  BZ    1AE8
01AE4:  INCF   502,F
01AE6:  BRA    1AEC
01AE8:  MOVF   502,F
01AEA:  BZ    1AF8
01AEC:  MOVFF  4E6,4EE
01AF0:  DECFSZ 501,F
01AF2:  BRA    1AEC
01AF4:  DECFSZ 502,F
01AF6:  BRA    1AEC
....................     ++history->itemsCount;
01AF8:  MOVLW  06
01AFA:  ADDWF  553,W
01AFC:  MOVWF  4E9
01AFE:  MOVLW  00
01B00:  ADDWFC 554,W
01B02:  MOVWF  4EA
01B04:  MOVLW  01
01B06:  ADDWF  4EE,F
01B08:  BNC   1B0C
01B0A:  INCF   4EF,F
.................... 
....................     return true;
01B0C:  MOVLW  01
01B0E:  MOVWF  501
01B10:  MOVLB  0
01B12:  GOTO   2456 (RETURN)
.................... }
.................... 
.................... static char *historyGet(CliHistory *history, uint16_t item) {
....................     if (item == 0 || item > history->itemsCount)
*
00BAC:  MOVLB  5
00BAE:  MOVF   x65,F
00BB0:  BNZ   0BB6
00BB2:  MOVF   x66,F
00BB4:  BZ    0BDA
00BB6:  MOVLW  06
00BB8:  ADDWF  x63,W
00BBA:  MOVWF  4E9
00BBC:  MOVLW  00
00BBE:  ADDWFC x64,W
00BC0:  MOVWF  4EA
00BC2:  MOVFF  4EC,503
00BC6:  MOVF   4ED,F
00BC8:  MOVFF  4EF,501
00BCC:  MOVF   503,W
00BCE:  SUBWF  x66,W
00BD0:  BNC   0BE2
00BD2:  BNZ   0BDA
00BD4:  MOVF   x65,W
00BD6:  SUBWF  501,W
00BD8:  BC    0BE2
....................         return NULL;
00BDA:  MOVLW  00
00BDC:  MOVWF  501
00BDE:  MOVWF  502
00BE0:  BRA    0C04
.................... 
....................     // items are stored in the same way (separated by \0 and counted from 1),
....................     // so can use this call
....................     return embeddedCliGetToken(history->buf, item);
00BE2:  MOVFF  563,4E9
00BE6:  MOVFF  564,4EA
00BEA:  MOVFF  4EC,5CB
00BEE:  MOVF   4ED,F
00BF0:  MOVFF  4EF,5CA
00BF4:  MOVFF  566,5CD
00BF8:  MOVFF  565,5CC
00BFC:  MOVLB  0
00BFE:  RCALL  0B6A
00C00:  MOVF   502,W
00C02:  MOVLB  5
00C04:  MOVLB  0
00C06:  RETURN 0
.................... }
.................... 
.................... static void historyRemove(CliHistory *history, char *str) {
....................     if (str == NULL || history->itemsCount == 0)
*
01744:  MOVLB  5
01746:  MOVF   x63,F
01748:  BNZ   174E
0174A:  MOVF   x64,F
0174C:  BZ    176C
0174E:  MOVLW  06
01750:  ADDWF  x61,W
01752:  MOVWF  4E9
01754:  MOVLW  00
01756:  ADDWFC x62,W
01758:  MOVWF  4EA
0175A:  MOVFF  4EC,56E
0175E:  MOVF   4ED,F
01760:  MOVFF  4EF,56D
01764:  MOVF   x6D,F
01766:  BNZ   176E
01768:  MOVF   x6E,F
0176A:  BNZ   176E
....................         return;
0176C:  BRA    18E2
....................     char *item = NULL;
....................     uint16_t itemPosition;
0176E:  CLRF   x66
01770:  CLRF   x65
....................     for (itemPosition = 1; itemPosition <= history->itemsCount; ++itemPosition) {
01772:  CLRF   x68
01774:  MOVLW  01
01776:  MOVWF  x67
01778:  MOVLW  06
0177A:  ADDWF  x61,W
0177C:  MOVWF  4E9
0177E:  MOVLW  00
01780:  ADDWFC x62,W
01782:  MOVWF  4EA
01784:  MOVFF  4EC,503
01788:  MOVF   4ED,F
0178A:  MOVFF  4EF,501
0178E:  MOVF   x68,W
01790:  SUBWF  503,W
01792:  BNC   17EC
01794:  BNZ   179C
01796:  MOVF   x67,W
01798:  SUBWF  501,W
0179A:  BNC   17EC
....................         // items are stored in the same way (separated by \0 and counted from 1),
....................         // so can use this call
....................         item = embeddedCliGetTokenVariable(history->buf, itemPosition);
0179C:  MOVFF  561,4E9
017A0:  MOVFF  562,4EA
017A4:  MOVFF  4EC,570
017A8:  MOVF   4ED,F
017AA:  MOVFF  4EF,56F
017AE:  MOVFF  568,572
017B2:  MOVFF  567,571
017B6:  MOVLB  0
017B8:  BRA    15A6
017BA:  MOVFF  502,566
017BE:  MOVFF  501,565
....................         if (strcmp(item, str) == 0) {
017C2:  MOVFF  566,5D1
017C6:  MOVFF  565,5D0
017CA:  MOVFF  564,5D3
017CE:  MOVFF  563,5D2
017D2:  RCALL  15EC
017D4:  MOVF   501,F
017D6:  BNZ   17DE
....................             break;
017D8:  MOVLB  5
017DA:  BRA    17EC
017DC:  MOVLB  0
....................         }
....................         item = NULL;
017DE:  MOVLB  5
017E0:  CLRF   x66
017E2:  CLRF   x65
017E4:  INCF   x67,F
017E6:  BTFSC  4D8.2
017E8:  INCF   x68,F
017EA:  BRA    1778
....................     }
....................     if (item == NULL)
017EC:  MOVF   x65,F
017EE:  BNZ   17F6
017F0:  MOVF   x66,F
017F2:  BNZ   17F6
....................         return;
017F4:  BRA    18E2
.................... 
....................     --history->itemsCount;
017F6:  MOVLW  06
017F8:  ADDWF  x61,W
017FA:  MOVWF  4E9
017FC:  MOVLW  00
017FE:  ADDWFC x62,W
01800:  MOVWF  4EA
01802:  MOVLW  FF
01804:  ADDWF  4EF,F
01806:  BC    180C
01808:  MOVF   4EE,F
0180A:  DECF   4ED,F
....................     if (itemPosition == (history->itemsCount + 1)) {
0180C:  MOVLW  06
0180E:  ADDWF  x61,W
01810:  MOVWF  4E9
01812:  MOVLW  00
01814:  ADDWFC x62,W
01816:  MOVWF  4EA
01818:  MOVFF  4EC,56E
0181C:  MOVF   4ED,F
0181E:  MOVFF  4EF,56D
01822:  MOVLW  01
01824:  ADDWF  x6D,W
01826:  MOVWF  501
01828:  MOVLW  00
0182A:  ADDWFC x6E,W
0182C:  MOVWF  503
0182E:  MOVF   501,W
01830:  SUBWF  x67,W
01832:  BNZ   183C
01834:  MOVF   503,W
01836:  SUBWF  x68,W
01838:  BNZ   183C
....................         // if this is a last element, nothing is remaining to move
....................         return;
0183A:  BRA    18E2
....................     }
.................... 
....................     size_t len = strlen(item);
....................     size_t remaining = (size_t) (history->bufferSize - (item + len + 1 - history->buf));
0183C:  MOVFF  566,61B
01840:  MOVFF  565,61A
01844:  MOVLB  0
01846:  CALL   0768
0184A:  MOVFF  502,56A
0184E:  MOVFF  501,569
01852:  MOVLW  02
01854:  MOVLB  5
01856:  ADDWF  x61,W
01858:  MOVWF  4E9
0185A:  MOVLW  00
0185C:  ADDWFC x62,W
0185E:  MOVWF  4EA
01860:  MOVFF  4EC,56E
01864:  MOVF   4ED,F
01866:  MOVFF  4EF,56D
0186A:  MOVF   x69,W
0186C:  ADDWF  x65,W
0186E:  MOVWF  x6F
01870:  MOVF   x6A,W
01872:  ADDWFC x66,W
01874:  MOVWF  x70
01876:  MOVLW  01
01878:  ADDWF  x6F,F
0187A:  MOVLW  00
0187C:  ADDWFC x70,F
0187E:  MOVFF  561,4E9
01882:  MOVFF  562,4EA
01886:  MOVFF  4EC,503
0188A:  MOVF   4ED,F
0188C:  MOVF   4EF,W
0188E:  SUBWF  x6F,W
01890:  MOVWF  500
01892:  MOVF   503,W
01894:  SUBWFB x70,W
01896:  MOVWF  503
01898:  MOVF   500,W
0189A:  SUBWF  x6D,W
0189C:  MOVWF  500
0189E:  MOVF   503,W
018A0:  SUBWFB x6E,W
018A2:  MOVFF  500,56B
018A6:  MOVWF  x6C
....................     // move everything to the right of found item
....................     memmove(item, &item[len + 1], remaining);
018A8:  MOVLW  01
018AA:  ADDWF  x69,W
018AC:  MOVWF  x6D
018AE:  MOVLW  00
018B0:  ADDWFC x6A,W
018B2:  MOVWF  x6E
018B4:  MOVF   x65,W
018B6:  ADDWF  x6D,W
018B8:  MOVWF  501
018BA:  MOVF   x66,W
018BC:  ADDWFC x6E,W
018BE:  MOVWF  503
018C0:  MOVFF  501,56F
018C4:  MOVWF  x70
018C6:  MOVFF  566,572
018CA:  MOVFF  565,571
018CE:  MOVWF  x74
018D0:  MOVFF  501,573
018D4:  MOVFF  56C,576
018D8:  MOVFF  56B,575
018DC:  MOVLB  0
018DE:  RCALL  1664
018E0:  MOVLB  5
018E2:  MOVLB  0
018E4:  GOTO   194A (RETURN)
.................... }
.................... 
.................... static uint16_t getTokenPosition(char *tokenizedStr, uint16_t pos) {
....................     if (tokenizedStr == NULL || pos == 0)
*
00AD6:  MOVLB  5
00AD8:  MOVF   xD0,F
00ADA:  BNZ   0AE0
00ADC:  MOVF   xD1,F
00ADE:  BZ    0AE8
00AE0:  MOVF   xD2,F
00AE2:  BNZ   0AF0
00AE4:  MOVF   xD3,F
00AE6:  BNZ   0AF0
....................         return CLI_TOKEN_NPOS;
00AE8:  MOVLW  FF
00AEA:  MOVWF  501
00AEC:  MOVWF  502
00AEE:  BRA    0B66
....................     uint16_t i = 0;
....................     uint16_t tokenCount = 1;
00AF0:  CLRF   xD5
00AF2:  CLRF   xD4
00AF4:  CLRF   xD7
00AF6:  MOVLW  01
00AF8:  MOVWF  xD6
....................     while (true) {
....................         if (tokenCount == pos)
00AFA:  MOVF   xD2,W
00AFC:  SUBWF  xD6,W
00AFE:  BNZ   0B08
00B00:  MOVF   xD3,W
00B02:  SUBWF  xD7,W
00B04:  BNZ   0B08
....................             break;
00B06:  BRA    0B44
.................... 
....................         if (tokenizedStr[i] == '\0') {
00B08:  MOVF   xD0,W
00B0A:  ADDWF  xD4,W
00B0C:  MOVWF  4E9
00B0E:  MOVF   xD1,W
00B10:  ADDWFC xD5,W
00B12:  MOVWF  4EA
00B14:  MOVF   4EF,F
00B16:  BNZ   0B3C
....................             ++tokenCount;
00B18:  INCF   xD6,F
00B1A:  BTFSC  4D8.2
00B1C:  INCF   xD7,F
....................             if (tokenizedStr[i + 1] == '\0')
00B1E:  MOVLW  01
00B20:  ADDWF  xD4,W
00B22:  MOVWF  xD8
00B24:  MOVLW  00
00B26:  ADDWFC xD5,W
00B28:  MOVWF  xD9
00B2A:  MOVF   xD0,W
00B2C:  ADDWF  xD8,W
00B2E:  MOVWF  4E9
00B30:  MOVF   xD1,W
00B32:  ADDWFC xD9,W
00B34:  MOVWF  4EA
00B36:  MOVF   4EF,F
00B38:  BNZ   0B3C
....................                 break;
00B3A:  BRA    0B44
....................         }
.................... 
....................         ++i;
00B3C:  INCF   xD4,F
00B3E:  BTFSC  4D8.2
00B40:  INCF   xD5,F
00B42:  BRA    0AFA
....................     }
.................... 
....................     if (tokenizedStr[i] != '\0')
00B44:  MOVF   xD0,W
00B46:  ADDWF  xD4,W
00B48:  MOVWF  4E9
00B4A:  MOVF   xD1,W
00B4C:  ADDWFC xD5,W
00B4E:  MOVWF  4EA
00B50:  MOVF   4EF,F
00B52:  BZ    0B60
....................         return i;
00B54:  MOVFF  5D4,501
00B58:  MOVFF  5D5,502
00B5C:  BRA    0B66
00B5E:  BRA    0B66
....................     else
....................         return CLI_TOKEN_NPOS;
00B60:  MOVLW  FF
00B62:  MOVWF  501
00B64:  MOVWF  502
00B66:  MOVLB  0
00B68:  RETURN 0
.................... }
.................... #ifdef __cplusplus
.................... }
.................... #endif
.................... #endif // EMBEDDED_CLI_IMPL_GUARD
.................... #endif // EMBEDDED_CLI_IMPL
.................... 
.................... 
.................... 
.................... EmbeddedCli *cli = embeddedCliNewDefault();
.................... 
.................... void writeChar(EmbeddedCli *embeddedCli, char c)
.................... {
*
007A0:  RETURN 0
....................   // Hello !
....................   // Handle some serial characters here
....................   
.................... }
.................... 
.................... void onCommand(EmbeddedCli *embeddedCli, CliCommand *command)
.................... {
*
023B0:  RETURN 0
....................     // your implementation
.................... 
.................... }
.................... 
.................... void main()
*
02D8A:  CLRF   4F8
02D8C:  BCF    4D6.5
02D8E:  CLRF   xB0
02D90:  CLRF   xAF
02D92:  CLRF   xB3
02D94:  MOVLW  08
02D96:  MOVWF  xB1
02D98:  MOVLW  60
02D9A:  MOVWF  xAD
02D9C:  GOTO   074E
02DA0:  MOVFF  502,524
02DA4:  MOVFF  501,523
02DA8:  MOVLB  4
02DAA:  CLRF   x00
02DAC:  CLRF   x08
02DAE:  CLRF   x10
02DB0:  CLRF   x18
02DB2:  CLRF   x20
02DB4:  CLRF   x28
02DB6:  MOVLB  0
02DB8:  CLRF   x71
02DBA:  CLRF   x72
02DBC:  CLRF   x73
02DBE:  CLRF   x70
02DC0:  CLRF   x75
02DC2:  CLRF   x76
02DC4:  CLRF   x77
02DC6:  CLRF   x74
02DC8:  BRA    2DE0
02DCA:  DATA 02,05
02DCC:  DATA 04,00
02DCE:  DATA 00,0F
02DD0:  DATA 45,0A
02DD2:  DATA 00,0A
02DD4:  DATA 80,01
02DD6:  DATA 00,1D
02DD8:  DATA 05,0D
02DDA:  DATA 0A,00
02DDC:  DATA 3E,20
02DDE:  DATA 00,00
02DE0:  MOVLW  00
02DE2:  MOVWF  4F8
02DE4:  MOVLW  2D
02DE6:  MOVWF  4F7
02DE8:  MOVLW  CA
02DEA:  MOVWF  4F6
02DEC:  TBLRD*+
02DEE:  MOVF   4F5,W
02DF0:  MOVWF  500
02DF2:  XORLW  00
02DF4:  BZ    2E1C
02DF6:  TBLRD*+
02DF8:  MOVF   4F5,W
02DFA:  MOVWF  501
02DFC:  BTFSC  4E8.7
02DFE:  BRA    2E0A
02E00:  ANDLW  3F
02E02:  MOVWF  4EA
02E04:  TBLRD*+
02E06:  MOVFF  4F5,4E9
02E0A:  BTFSC  501.6
02E0C:  TBLRD*+
02E0E:  BTFSS  501.6
02E10:  TBLRD*+
02E12:  MOVFF  4F5,4EE
02E16:  DCFSNZ 500,F
02E18:  BRA    2DEC
02E1A:  BRA    2E0E
02E1C:  CLRF   4F8
02E1E:  CALL   0018
02E22:  MOVFF  502,533
02E26:  MOVFF  501,532
.................... {
.................... 
....................    EmbeddedCliConfig *config = embeddedCliDefaultConfig();
....................    config->maxBindingCount = 16;
02E2A:  MOVLW  08
02E2C:  ADDWF  532,W
02E2E:  MOVWF  4E9
02E30:  MOVLW  00
02E32:  ADDWFC 533,W
02E34:  MOVWF  4EA
02E36:  CLRF   4EC
02E38:  MOVF   4ED,F
02E3A:  MOVLW  10
02E3C:  MOVWF  4EF
....................    cli->onCommand = onCommand;
02E3E:  MOVLW  04
02E40:  ADDWF  523,W
02E42:  MOVWF  4E9
02E44:  MOVLW  00
02E46:  ADDWFC 524,W
02E48:  MOVWF  4EA
02E4A:  MOVLW  00
02E4C:  MOVWF  502
02E4E:  MOVLW  23
02E50:  MOVWF  501
02E52:  MOVLW  B0
02E54:  MOVWF  4EF
02E56:  MOVFF  501,4EC
02E5A:  MOVFF  502,4EC
02E5E:  CLRF   4EC
....................    cli->writeChar = writeChar;
02E60:  MOVFF  523,4E9
02E64:  MOVFF  524,4EA
02E68:  MOVLW  00
02E6A:  MOVWF  502
02E6C:  MOVLW  07
02E6E:  MOVWF  501
02E70:  MOVLW  A0
02E72:  MOVWF  4EF
02E74:  MOVFF  501,4EC
02E78:  MOVFF  502,4EC
02E7C:  CLRF   4EC
.................... 
....................    while(TRUE)
....................    {
....................       embeddedCliProcess(cli);
02E7E:  MOVFF  524,535
02E82:  MOVFF  523,534
02E86:  BRA    2BB0
02E88:  BRA    2E7E
.................... 
....................    }
.................... 
.................... }
.................... 
02E8A:  BRA    2E8A
.................... 
.................... /// For eCLI Command Processing
.................... void onLed(EmbeddedCli *cli, char *args, void *context)
.................... {
....................    // use args as raw null-terminated string of all arguments
....................   
....................    // Use if args should be tokenized
.................... //   cnst char * arg = embeddedCliGetToken(args, pos); // args are counted from 1 (not from 0)
.................... // uint8_t pos = embeddedCliFindToken(args, argument);
.................... // uint8_t count = embeddedCliGetTokenCount(const char *tokenizedStr);
.................... 
.................... }

Configuration Fuses:
   Word  1: EF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT PRLOCK1WAY CKS NOJTAG FCMEN PFCMEN SFCMEN
   Word  2: DFF7   MCLR NOPUT NOMVECEN IVT1WAY NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NOLVP NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: FFDF   BBSIZ512 NOBOOTBLOCK NOSAF DEBUG NOWRTB NOWRTC NOWRTD NOWRTSAF NOWRT
   Word  5: FFFF   CRCBOOTPINC5 NOCRCBOOTPIN CRCBOOTPIN_DRIVEN NOPROTECT
   Word  6: FFFF   NOCRCSCANBB CRCBBSCANERR_STOP NOCRCSCANAPP NOCRCSCANSAF NOCRCSCANEE NOCRCSCANCONFIG NOCRCBOOTSCAN
   Word  7: FFFF  
   Word  8: FFFF  
   Word  9: FFFF  
   Word 10: FFFF  
   Word 11: FFFF  
   Word 12: FFFF  
   Word 13: FFFF  
   Word 14: FFFF  
   Word 15: FFFF  
   Word 16: FFFF  
   Word 17: FFFF  
   Word 18: FFFF  

   Some fuses have been forced to be compatible with the ICD debugger.
