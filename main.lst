CCS PCH C Compiler, Version 5.116, 749               13-Nov-23 13:47

               Filename:   C:\Users\beadon\Documents\GitHub\ecli_demo\main.lst

               ROM used:   62 bytes (0%)
                           Largest free fragment is 65536
               RAM used:   4 (0%) at main() level
                           4 (0%) worst case
               Stack used: 0 locations
               Stack size: 126

*
00000:  GOTO   0004
.................... #include "main.h"
.................... #include <18F57Q84.h>
.................... //////////// Standard Header file for the PIC18F57Q84 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F57Q84
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... 
.................... #device ICD=TRUE
.................... #use delay(internal=64MHz)
.................... 
.................... 
.................... // Supposed to be provided by stdint.h, hardware specific
.................... // required for eCLI.
.................... 
.................... #ifndef UINTPTR_MAX
.................... #define UINTPTR_MAX 0xFFFF
.................... #endif
.................... 
.................... #define EMBEDDED_CLI_IMPL
.................... #include "embedded_cli.h"
.................... #ifndef EMBEDDED_CLI_H
.................... #define EMBEDDED_CLI_H
.................... 
.................... 
.................... #ifdef __cplusplus
.................... 
.................... extern "C" {
.................... #else
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... // cstdint is available only since C++11, so use C header
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // used for proper alignment of cli buffer
.................... #if UINTPTR_MAX == 0xFFFF
.................... #define CLI_UINT uint16_t
.................... #elif UINTPTR_MAX == 0xFFFFFFFF
.................... #define CLI_UINT uint32_t
.................... #elif UINTPTR_MAX == 0xFFFFFFFFFFFFFFFFu
.................... #define CLI_UINT uint64_t
.................... #else
.................... #error unsupported pointer size
.................... #endif
.................... 
.................... #define CLI_UINT_SIZE (sizeof(CLI_UINT))
.................... // convert size in bytes to size in terms of CLI_UINTs (rounded up
.................... // if bytes is not divisible by size of single CLI_UINT)
.................... #define BYTES_TO_CLI_UINTS(bytes) \
....................   (((bytes) + CLI_UINT_SIZE - 1)/CLI_UINT_SIZE)
.................... 
.................... typedef struct CliCommand CliCommand;
.................... typedef struct CliCommandBinding CliCommandBinding;
.................... typedef struct EmbeddedCli EmbeddedCli;
.................... typedef struct EmbeddedCliConfig EmbeddedCliConfig;
.................... 
.................... 
.................... struct CliCommand {
....................     /**
....................      * Name of the command.
....................      * In command "set led 1 1" "set" is name
....................      */
....................     char *name;
.................... 
....................     /**
....................      * String of arguments of the command.
....................      * In command "set led 1 1" "led 1 1" is string of arguments
....................      * Is ended with double 0x00 char
....................      * Use tokenize functions to easily get individual tokens
....................      */
....................     char *args;
.................... };
.................... 
.................... /**
....................  * Struct to describe binding of command to function and
....................  */
.................... struct CliCommandBinding {
....................     /**
....................      * Name of command to bind. Should not be NULL.
....................      */
....................     char *name;
.................... 
....................     /**
....................      * Help string that will be displayed when "help <cmd>" is executed.
....................      * Can have multiple lines separated with "\r\n"
....................      * Can be NULL if no help is provided.
....................      */
....................     char *help;
.................... 
....................     /**
....................      * Flag to perform tokenization before calling binding function.
....................      */
....................     bool tokenizeArgs;
.................... 
....................     /**
....................      * Pointer to any specific app context that is required for this binding.
....................      * It will be provided in binding callback.
....................      */
....................     void *context;
.................... 
....................     /**
....................      * Binding function for when command is received.
....................      * If null, default callback (onCommand) will be called.
....................      * @param cli - pointer to cli that is calling this binding
....................      * @param args - string of args (if tokenizeArgs is false) or tokens otherwise
....................      * @param context
....................      */
....................     void (*binding)(EmbeddedCli *cli, char *args, void *context);
.................... };
.................... 
.................... struct EmbeddedCli {
....................     /**
....................      * Should write char to connection
....................      * @param cli - pointer to cli that executed this function
....................      * @param c   - actual character to write
....................      */
....................     void (*writeChar)(EmbeddedCli *cli, char c);
.................... 
....................     /**
....................      * Called when command is received and command not found in list of
....................      * command bindings (or binding function is null).
....................      * @param cli     - pointer to cli that executed this function
....................      * @param command - pointer to received command
....................      */
....................     void (*onCommand)(EmbeddedCli *cli, CliCommand *command);
.................... 
....................     /**
....................      * Can be used for any application context
....................      */
....................     void *appContext;
.................... 
....................     /**
....................      * Pointer to actual implementation, do not use.
....................      */
....................     void *_impl;
.................... };
.................... 
.................... /**
....................  * Configuration to create CLI
....................  */
.................... struct EmbeddedCliConfig {
....................     /**
....................      * Invitation string. Is printed at the beginning of each line with user
....................      * input
....................      */
....................     char *invitation;
....................     
....................     /**
....................      * Size of buffer that is used to store characters until they're processed
....................      */
....................     uint16_t rxBufferSize;
.................... 
....................     /**
....................      * Size of buffer that is used to store current input that is not yet
....................      * sended as command (return not pressed yet)
....................      */
....................     uint16_t cmdBufferSize;
.................... 
....................     /**
....................      * Size of buffer that is used to store previously entered commands
....................      * Only unique commands are stored in buffer. If buffer is smaller than
....................      * entered command (including arguments), command is discarded from history
....................      */
....................     uint16_t historyBufferSize;
.................... 
....................     /**
....................      * Maximum amount of bindings that can be added via addBinding function.
....................      * Cli increases takes extra bindings for internal commands:
....................      * - help
....................      */
....................     uint16_t maxBindingCount;
.................... 
....................     /**
....................      * Buffer to use for cli and all internal structures. If NULL, memory will
....................      * be allocated dynamically. Otherwise this buffer is used and no
....................      * allocations are made
....................      */
....................     CLI_UINT *cliBuffer;
.................... 
....................     /**
....................      * Size of buffer for cli and internal structures (in bytes).
....................      */
....................     uint16_t cliBufferSize;
.................... 
....................     /**
....................      * Whether autocompletion should be enabled.
....................      * If false, autocompletion is disabled but you still can use 'tab' to
....................      * complete current command manually.
....................      */
....................     bool enableAutoComplete;
.................... };
.................... 
.................... /**
....................  * Returns pointer to default configuration for cli creation. It is safe to
....................  * modify it and then send to embeddedCliNew().
....................  * Returned structure is always the same so do not free and try to use it
....................  * immediately.
....................  * Default values:
....................  * <ul>
....................  * <li>rxBufferSize = 64</li>
....................  * <li>cmdBufferSize = 64</li>
....................  * <li>historyBufferSize = 128</li>
....................  * <li>cliBuffer = NULL (use dynamic allocation)</li>
....................  * <li>cliBufferSize = 0</li>
....................  * <li>maxBindingCount = 8</li>
....................  * <li>enableAutoComplete = true</li>
....................  * </ul>
....................  * @return configuration for cli creation
....................  */
.................... EmbeddedCliConfig *embeddedCliDefaultConfig(void);
.................... 
.................... /**
....................  * Returns how many space in config buffer is required for cli creation
....................  * If you provide buffer with less space, embeddedCliNew will return NULL
....................  * This amount will always be divisible by CLI_UINT_SIZE so allocated buffer
....................  * and internal structures can be properly aligned
....................  * @param config
....................  * @return
....................  */
.................... uint16_t embeddedCliRequiredSize(EmbeddedCliConfig *config);
.................... 
.................... /**
....................  * Create new CLI.
....................  * Memory is allocated dynamically if cliBuffer in config is NULL.
....................  * After CLI is created, override function pointers to start using it
....................  * @param config - config for cli creation
....................  * @return pointer to created CLI
....................  */
.................... EmbeddedCli *embeddedCliNew(EmbeddedCliConfig *config);
.................... 
.................... /**
....................  * Same as calling embeddedCliNew with default config.
....................  * @return
....................  */
.................... EmbeddedCli *embeddedCliNewDefault(void);
.................... 
.................... /**
....................  * Receive character and put it to internal buffer
....................  * Actual processing is done inside embeddedCliProcess
....................  * You can call this function from something like interrupt service routine,
....................  * just make sure that you call it only from single place. Otherwise input
....................  * might get corrupted
....................  * @param cli
....................  * @param c   - received char
....................  */
.................... void embeddedCliReceiveChar(EmbeddedCli *cli, char c);
.................... 
.................... /**
....................  * Process rx/tx buffers. Command callbacks are called from here
....................  * @param cli
....................  */
.................... void embeddedCliProcess(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Add specified binding to list of bindings. If list is already full, binding
....................  * is not added and false is returned
....................  * @param cli
....................  * @param binding
....................  * @return true if binding was added, false otherwise
....................  */
.................... bool embeddedCliAddBinding(EmbeddedCli *cli, CliCommandBinding binding);
.................... 
.................... /**
....................  * Print specified string and account for currently entered but not submitted
....................  * command.
....................  * Current command is deleted, provided string is printed (with new line) after
....................  * that current command is printed again, so user can continue typing it.
....................  * @param cli
....................  * @param string
....................  */
.................... void embeddedCliPrint(EmbeddedCli *cli, char *string);
.................... 
.................... /**
....................  * Free allocated for cli memory
....................  * @param cli
....................  */
.................... void embeddedCliFree(EmbeddedCli *cli);
.................... 
.................... /**
....................  * Perform tokenization of arguments string. Original string is modified and
....................  * should not be used directly (only inside other token functions).
....................  * Individual tokens are separated by single 0x00 char, double 0x00 is put at
....................  * the end of token list. After calling this function, you can use other
....................  * token functions to get individual tokens and token count.
....................  *
....................  * Important: Call this function only once. Otherwise information will be lost if
....................  * more than one token existed
....................  * @param args - string to tokenize (must have extra writable char after 0x00)
....................  * @return
....................  */
.................... void embeddedCliTokenizeArgs(char *args);
.................... 
.................... /**
....................  * Return specific token from tokenized string
....................  * @param tokenizedStr
....................  * @param pos (counted from 1)
....................  * @return token
....................  */
.................... char *embeddedCliGetToken(char *tokenizedStr, uint16_t pos);
.................... 
.................... /**
....................  * Same as embeddedCliGetToken but works on non-const buffer
....................  * @param tokenizedStr
....................  * @param pos (counted from 1)
....................  * @return token
....................  */
.................... char *embeddedCliGetTokenVariable(char *tokenizedStr, uint16_t pos);
.................... 
.................... /**
....................  * Find token in provided tokens string and return its position (counted from 1)
....................  * If no such token is found - 0 is returned.
....................  * @param tokenizedStr
....................  * @param token - token to find
....................  * @return position (increased by 1) or zero if no such token found
....................  */
.................... uint16_t embeddedCliFindToken(char *tokenizedStr, char *token);
.................... 
.................... /**
....................  * Return number of tokens in tokenized string
....................  * @param tokenizedStr
....................  * @return number of tokens
....................  */
.................... uint16_t embeddedCliGetTokenCount(char *tokenizedStr);
.................... 
.................... #ifdef __cplusplus
.................... }
.................... #endif
.................... 
.................... 
.................... #endif //EMBEDDED_CLI_H
.................... 
.................... 
.................... void main()
00004:  CLRF   4F8
00006:  BCF    4D6.5
00008:  CLRF   xB0
0000A:  CLRF   xAF
0000C:  CLRF   xB3
0000E:  MOVLW  08
00010:  MOVWF  xB1
00012:  MOVLW  60
00014:  MOVWF  xAD
00016:  MOVLB  4
00018:  CLRF   x00
0001A:  CLRF   x08
0001C:  CLRF   x10
0001E:  CLRF   x18
00020:  CLRF   x20
00022:  CLRF   x28
00024:  MOVLB  0
00026:  CLRF   x71
00028:  CLRF   x72
0002A:  CLRF   x73
0002C:  CLRF   x70
0002E:  CLRF   x75
00030:  CLRF   x76
00032:  CLRF   x77
00034:  CLRF   x74
.................... {
.................... 
....................    while(TRUE)
....................    {
00036:  GOTO   0036
....................       
.................... 
....................       //TODO: User Code
....................    }
.................... 
.................... }
0003A:  GOTO   003A

Configuration Fuses:
   Word  1: EF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT PRLOCK1WAY CKS NOJTAG FCMEN PFCMEN SFCMEN
   Word  2: DFF7   MCLR NOPUT NOMVECEN IVT1WAY NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NOLVP NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: FFDF   BBSIZ512 NOBOOTBLOCK NOSAF DEBUG NOWRTB NOWRTC NOWRTD NOWRTSAF NOWRT
   Word  5: FFFF   CRCBOOTPINC5 NOCRCBOOTPIN CRCBOOTPIN_DRIVEN NOPROTECT
   Word  6: FFFF   NOCRCSCANBB CRCBBSCANERR_STOP NOCRCSCANAPP NOCRCSCANSAF NOCRCSCANEE NOCRCSCANCONFIG NOCRCBOOTSCAN
   Word  7: FFFF  
   Word  8: FFFF  
   Word  9: FFFF  
   Word 10: FFFF  
   Word 11: FFFF  
   Word 12: FFFF  
   Word 13: FFFF  
   Word 14: FFFF  
   Word 15: FFFF  
   Word 16: FFFF  
   Word 17: FFFF  
   Word 18: FFFF  

   Some fuses have been forced to be compatible with the ICD debugger.
